from fastapi import FastAPI, HTTPException, Depends
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from datetime import datetime, timedelta
from typing import List, Optional
import uvicorn
import firebase_admin
from firebase_admin import credentials, firestore
import os
import secrets
import string
import qrcode
import io
import base64
from fastapi.responses import StreamingResponse
from twilio.rest import Client
from apscheduler.schedulers.background import BackgroundScheduler
import asyncio
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from enum import Enum

# Enum dla uprawnie≈Ñ u≈ºytkownika
class UserPermission(str, Enum):
    ADMIN = "Admin"
    STARTER = "Starter" 
    PROFESSIONAL = "Professional"
    DEMO = "Demo"

def get_sms_limit_for_permission(permission: UserPermission) -> int:
    limits = {
        UserPermission.ADMIN: 1000,        # Admin - nieograniczony praktycznie
        UserPermission.PROFESSIONAL: 200,  # Professional - 200 SMS
        UserPermission.STARTER: 50,       # Starter - 50 SMS  
        UserPermission.DEMO: 10            # Demo - 10 SMS
    }
    return limits.get(permission, 10)  # Domy≈õlnie 10 dla nieznanych uprawnie≈Ñ

def check_sms_limit(username: str) -> dict:
    """Sprawd≈∫ czy u≈ºytkownik nie przekroczy≈Ç limitu SMS"""
    try:
        # Pobierz ustawienia u≈ºytkownika
        doc_ref = db.collection(username).document("Dane")
        doc = doc_ref.get()
        
        if not doc.exists:
            return {"allowed": False, "message": "U≈ºytkownik nie istnieje"}
        
        settings_data = doc.to_dict()
        settings = UserSettings(**settings_data)
        
        # Pobierz limit z ustawie≈Ñ lub na podstawie uprawnie≈Ñ
        sms_limit = settings.messaging.smsLimit
        if sms_limit is None:
            sms_limit = get_sms_limit_for_permission(settings.permission)
        
        # Sprawd≈∫ czy trzeba zresetowaƒá limit (nowy miesiƒÖc)
        current_month = datetime.now().strftime("%Y-%m")
        last_reset_month = settings_data.get("messaging", {}).get("lastResetMonth", "")
        
        if last_reset_month != current_month:
            # Nowy miesiƒÖc - zresetuj limit
            reset_sms_limit_for_month(username, current_month, sms_limit)
        
        # Policz wys≈Çane SMS w tym miesiƒÖcu
        sms_collection = db.collection(username).document("SMS").collection(current_month)
        sent_sms_count = len(list(sms_collection.stream()))
        
        print(f"üìä Limit SMS dla {username}: {sms_limit}, wys≈Çane: {sent_sms_count}")
        
        if sent_sms_count >= sms_limit:
            return {
                "allowed": False, 
                "message": f"Przekroczono limit SMS ({sms_limit}). Wys≈Çano: {sent_sms_count}",
                "limit": sms_limit,
                "sent": sent_sms_count
            }
        
        return {
            "allowed": True,
            "message": f"Limit SMS: {sms_limit}, wys≈Çane: {sent_sms_count}",
            "limit": sms_limit,
            "sent": sent_sms_count,
            "remaining": sms_limit - sent_sms_count
        }
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas sprawdzania limitu SMS: {str(e)}")
        return {"allowed": False, "message": f"B≈ÇƒÖd sprawdzania limitu: {str(e)}"}

def reset_sms_limit_for_month(username: str, current_month: str, sms_limit: int):
    """Zresetuj limit SMS dla nowego miesiƒÖca"""
    try:
        print(f"üîÑ Resetowanie limitu SMS dla {username} na miesiƒÖc {current_month}")
        
        # Pobierz aktualne ustawienia
        doc_ref = db.collection(username).document("Dane")
        doc = doc_ref.get()
        
        if not doc.exists:
            print(f"‚ùå U≈ºytkownik {username} nie istnieje")
            return False
        
        settings_data = doc.to_dict()
        
        # Zaktualizuj ustawienia messaging
        if "messaging" not in settings_data:
            settings_data["messaging"] = {}
        
        settings_data["messaging"]["lastResetMonth"] = current_month
        settings_data["messaging"]["smsLimit"] = sms_limit
        settings_data["messaging"]["smsCount"] = 0  # Zresetuj licznik
        settings_data["updated_at"] = datetime.now().isoformat()
        
        # Zapisz zaktualizowane ustawienia
        doc_ref.set(settings_data)
        
        print(f"‚úÖ Limit SMS zresetowany dla {username}: {sms_limit} SMS na miesiƒÖc {current_month}")
        return True
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd resetowania limitu SMS: {str(e)}")
        return False

def convert_firebase_timestamp_to_naive(timestamp):
    """Bezpiecznie konwertuj Firebase Timestamp na naive datetime"""
    if not timestamp:
        return None
    
    if hasattr(timestamp, 'to_pydatetime'):
        dt = timestamp.to_pydatetime()
        # Upewnij siƒô, ≈ºe to jest naive datetime (bez strefy czasowej)
        if dt.tzinfo is not None:
            dt = dt.replace(tzinfo=None)
        return dt
    elif isinstance(timestamp, str):
        try:
            dt = datetime.fromisoformat(timestamp.replace('Z', '+00:00'))
            # Upewnij siƒô, ≈ºe to jest naive datetime (bez strefy czasowej)
            if dt.tzinfo is not None:
                dt = dt.replace(tzinfo=None)
            return dt
        except:
            return None
    elif isinstance(timestamp, datetime):
        # Je≈õli ju≈º jest datetime, upewnij siƒô ≈ºe jest naive
        if timestamp.tzinfo is not None:
            return timestamp.replace(tzinfo=None)
        return timestamp
    
    return None

def get_user_permission_from_db(username: str) -> UserPermission:
    """Pobierz uprawnienia u≈ºytkownika z bazy danych"""
    if not db:
        return UserPermission.DEMO
    
    try:
        doc_ref = db.collection(username).document("Dane")
        doc = doc_ref.get()
        
        if doc.exists:
            settings_data = doc.to_dict()
            settings = UserSettings(**settings_data)
            return settings.permission
        else:
            return UserPermission.DEMO  # Domy≈õlnie Demo je≈õli u≈ºytkownik nie istnieje
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas pobierania uprawnie≈Ñ dla {username}: {str(e)}")
        return UserPermission.DEMO

def check_user_permission(username: str, required_permission: UserPermission) -> bool:
    """Sprawd≈∫ czy u≈ºytkownik ma wymagane uprawnienia"""
    user_permission = get_user_permission_from_db(username)
    
    # Hierarchia uprawnie≈Ñ: Admin > Professional > Starter > Demo
    permission_hierarchy = {
        UserPermission.ADMIN: 4,
        UserPermission.PROFESSIONAL: 3,
        UserPermission.STARTER: 2,
        UserPermission.DEMO: 1
    }
    
    user_level = permission_hierarchy.get(user_permission, 1)
    required_level = permission_hierarchy.get(required_permission, 1)
    
    return user_level >= required_level

def ensure_user_exists(username: str, email: str = "", name: str = "", surname: str = "") -> bool:
    """Upewnij siƒô, ≈ºe u≈ºytkownik istnieje w bazie danych. Je≈õli nie, utw√≥rz go z domy≈õlnymi danymi."""
    if not db:
        return False
    
    try:
        doc_ref = db.collection(username).document("Dane")
        doc = doc_ref.get()
        
        if doc.exists:
            print(f"‚úÖ U≈ºytkownik {username} ju≈º istnieje w bazie danych")
            return True
        
        print(f"üîÑ Tworzenie rekordu dla u≈ºytkownika: {username}")
        
        # Utw√≥rz nowy rekord u≈ºytkownika z domy≈õlnymi danymi
        now = datetime.now()
        default_settings = UserSettings(
            userData=UserData(
                name=name,
                surname=surname,
                email=email,
                companyName="",
                googleCard=""
            ),
            messaging=MessagingSettings(
                reminderFrequency=7,
                messageTemplate="""Bardzo prosimy o zostawienie opinii o naszych us≈Çugach: [LINK]
Wasza opinia ma dla nas ogromne znaczenie i pomo≈ºe kolejnym klientom w wyborze.

Dziƒôkujemy!""",
                autoSendEnabled=False,
                sendTime={"hour": 10, "minute": 0}
            ),
            twilio=TwilioSettings(
                account_sid="ACfc0d69a38f5b328bc7783fa5829336b2",
                auth_token="611da96accd9e1d3c95a37a5c43f7856",
                phone_number="",
                messaging_service_sid="MG12792d6acd38447e77756a5ceb2c75f1"
            ),
            permission=UserPermission.DEMO  
        )
        
        # Zapisz ustawienia do bazy danych
        settings_dict = default_settings.dict()
        settings_dict.update({
            "created_at": now,
            "updated_at": now
        })
        
        doc_ref.set(settings_dict)
        print(f"‚úÖ Utworzono rekord u≈ºytkownika {username} z uprawnieniami Demo")
        return True
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas tworzenia rekordu u≈ºytkownika {username}: {str(e)}")
        return False

# Za≈Çaduj zmienne ≈õrodowiskowe z pliku .env (je≈õli istnieje)
try:
    from dotenv import load_dotenv
    load_dotenv()
    print("‚úÖ Za≈Çadowano zmienne ≈õrodowiskowe z pliku .env")
except ImportError:
    print("‚ö†Ô∏è python-dotenv nie zainstalowany - u≈ºywaj zmiennych systemowych")

# Inicjalizacja Twilio - bƒôdzie inicjalizowany per u≈ºytkownik z Firebase
twilio_client = None

# Inicjalizacja Firebase Admin
try:
    # Sprawd≈∫ czy Firebase jest ju≈º zainicjalizowany
    if not firebase_admin._apps:
        # Sprawd≈∫ czy istnieje plik z kluczem serwisowym (lokalne ≈õrodowisko)
        if os.path.exists("next-reviews-9d19c-firebase-adminsdk-fbsvc-ffec0c49f4.json"):
            cred = credentials.Certificate("next-reviews-9d19c-firebase-adminsdk-fbsvc-ffec0c49f4.json")
            firebase_admin.initialize_app(cred)
            print("‚úÖ Firebase Admin SDK zainicjalizowany z pliku lokalnego")
        else:
            firebase_config = {
                "type": "service_account",
                "project_id": os.getenv("FIREBASE_PROJECT_ID", "next-reviews-9d19c"),
                "private_key_id": os.getenv("FIREBASE_PRIVATE_KEY_ID"),
                "private_key": os.getenv("FIREBASE_PRIVATE_KEY", "").replace("\\n", "\n"),
                "client_email": os.getenv("FIREBASE_CLIENT_EMAIL"),
                "client_id": os.getenv("FIREBASE_CLIENT_ID"),
                "auth_uri": os.getenv("FIREBASE_AUTH_URI", "https://accounts.google.com/o/oauth2/auth"),
                "token_uri": os.getenv("FIREBASE_TOKEN_URI", "https://oauth2.googleapis.com/token"),
                "auth_provider_x509_cert_url": os.getenv("FIREBASE_AUTH_PROVIDER_X509_CERT_URL", "https://www.googleapis.com/oauth2/v1/certs"),
                "client_x509_cert_url": os.getenv("FIREBASE_CLIENT_X509_CERT_URL")
            }
            
            # Sprawd≈∫ czy wszystkie wymagane zmienne sƒÖ ustawione
            required_vars = ["FIREBASE_PRIVATE_KEY_ID", "FIREBASE_PRIVATE_KEY", "FIREBASE_CLIENT_EMAIL", "FIREBASE_CLIENT_ID", "FIREBASE_CLIENT_X509_CERT_URL"]
            missing_vars = [var for var in required_vars if not os.getenv(var)]
            
            if missing_vars:
                print(f"‚ö†Ô∏è BrakujƒÖce zmienne ≈õrodowiskowe: {missing_vars}")
                print("üîÑ Pr√≥ba inicjalizacji z domy≈õlnymi po≈õwiadczeniami...")
                firebase_admin.initialize_app()
            else:
                cred = credentials.Certificate(firebase_config)
                firebase_admin.initialize_app(cred)
                print("‚úÖ Firebase Admin SDK zainicjalizowany ze zmiennych ≈õrodowiskowych")
        
        print("‚úÖ Firebase Admin SDK zainicjalizowany pomy≈õlnie")
    else:
        print("‚úÖ Firebase Admin SDK ju≈º zainicjalizowany")
    
    db = firestore.client()
except Exception as e:
    print(f"‚ùå B≈ÇƒÖd inicjalizacji Firebase: {e}")
    db = None

app = FastAPI(
    title="next review booster API", 
    version="1.0.0",
    description="API dla aplikacji next review booster - zarzƒÖdzanie recenzjami"
)
app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "http://localhost:3000", 
        "https://next-reviews-9d19c.web.app",  # Stara domena Firebase (backup)
        "https://next-reviews-booster-app.web.app",  # Nowa domena Firebase
        "https://next-reviews-booster.com",  # Docelowa domena
        "https://www.next-reviews-booster.com",  # Wariant z www
        "https://next-reviews-frontend.onrender.com",  # Frontend na Render
        "https://*.onrender.com"  # Wszystkie domeny Render
    ],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

class HealthResponse(BaseModel):
    status: str
    message: str
    timestamp: datetime
    version: str = "1.0.0"

# Modele danych dla klient√≥w
class ClientCreate(BaseModel):
    name: str
    phone: str
    note: str = ""
    stars: int = 0
    review: str = ""
    review_code: str = ""
    review_status: str = "not_sent"
    last_sms_sent: Optional[datetime] = None
    sms_count: int = 0
    source: str = "CRM"

class ClientUpdate(BaseModel):
    name: Optional[str] = None
    phone: Optional[str] = None
    note: Optional[str] = None
    stars: Optional[int] = None
    review: Optional[str] = None
    review_code: Optional[str] = None
    review_status: Optional[str] = None
    last_sms_sent: Optional[datetime] = None
    sms_count: Optional[int] = None
    source: Optional[str] = None

class ClientResponse(BaseModel):
    id: str
    name: str
    phone: str
    note: str = ""
    stars: int = 0
    review: str = ""
    review_code: str = ""
    review_status: str = "not_sent"
    created_at: datetime
    updated_at: datetime
    last_sms_sent: Optional[datetime] = None
    sms_count: int = 0
    source: str = "CRM"

class ClientListResponse(BaseModel):
    clients: List[ClientResponse]
    total: int

# Modele dla ustawie≈Ñ u≈ºytkownika
class UserData(BaseModel):
    name: str
    surname: str
    email: str
    companyName: str = ""
    googleCard: str = ""


class TwilioSettings(BaseModel):
    account_sid: str = ""
    auth_token: str = ""
    phone_number: str = "" 
    messaging_service_sid: str = "" 

class MessagingSettings(BaseModel):
    reminderFrequency: int = 7
    messageTemplate: str = ""
    autoSendEnabled: bool = False  
    sendTime: dict = {"hour": 10, "minute": 0}  # Domy≈õlnie 10:00
    smsLimit: int = 10
    smsCount: int = 0  # Licznik wys≈Çanych SMS

class UserSettings(BaseModel):
    userData: UserData
    messaging: MessagingSettings
    twilio: Optional[TwilioSettings] = None
    permission: UserPermission = UserPermission.DEMO  # Domy≈õlnie Demo dla nowych u≈ºytkownik√≥w

class UserSettingsResponse(BaseModel):
    settings: UserSettings

# Modele dla formularza ocen
class ReviewSubmission(BaseModel):
    stars: int
    review: str

class ReviewResponse(BaseModel):
    success: bool
    message: str

# Modele dla kod√≥w QR
class QRCodeRequest(BaseModel):
    size: int = 200
    format: str = "png"

class QRCodeResponse(BaseModel):
    qr_code: str
    company_name: str
    review_url: str

# Modele dla logowania klienta
class ClientLoginRequest(BaseModel):
    name: str
    phone: str
    note: str = ""
    stars: int = 0

class ClientLoginResponse(BaseModel):
    review_code: str
    message: str

# Modele dla SMS
class SMSRequest(BaseModel):
    to_phone: str
    message: str
    client_name: str = ""

class SMSResponse(BaseModel):
    success: bool
    message: str
    sid: Optional[str] = None

# Modele dla formularza kontaktowego
class ContactFormRequest(BaseModel):
    name: str
    email: str
    company: Optional[str] = ""
    message: str

class ContactFormResponse(BaseModel):
    success: bool
    message: str

# Funkcja do inicjalizacji Twilio dla konkretnego u≈ºytkownika
def get_twilio_client_for_user(username: str):
    """Pobierz klienta Twilio dla konkretnego u≈ºytkownika z Firebase"""
    if not db:
        return None
    
    try:
        # Pobierz ustawienia u≈ºytkownika
        settings_doc = db.collection(username).document("Dane").get()
        
        if not settings_doc.exists:
            print(f"‚ö†Ô∏è Brak ustawie≈Ñ dla u≈ºytkownika: {username}")
            return None
        
        settings_data = settings_doc.to_dict()
        
        # Sprawd≈∫ czy u≈ºytkownik ma skonfigurowane Twilio
        if "twilio" not in settings_data:
            print(f"‚ö†Ô∏è U≈ºytkownik {username} nie ma skonfigurowanego Twilio")
            return None
        
        twilio_config = settings_data["twilio"]
        
        account_sid = twilio_config.get("account_sid")
        auth_token = twilio_config.get("auth_token")
        phone_number = twilio_config.get("phone_number")
        messaging_service_sid = twilio_config.get("messaging_service_sid")
        
        # Sprawd≈∫ czy mamy podstawowe dane (account_sid i auth_token sƒÖ wymagane)
        if not all([account_sid, auth_token]):
            print(f"‚ö†Ô∏è Niekompletna konfiguracja Twilio dla u≈ºytkownika: {username}")
            return None
        
        # Sprawd≈∫ czy mamy messaging_service_sid (preferowane) lub phone_number (fallback)
        if not messaging_service_sid and not phone_number:
            print(f"‚ö†Ô∏è Brak messaging_service_sid ani phone_number dla u≈ºytkownika: {username}")
            return None
        
        # Utw√≥rz klienta Twilio
        client = Client(account_sid, auth_token)
        print(f"‚úÖ Twilio skonfigurowany dla u≈ºytkownika: {username}")
        
        return {
            "client": client,
            "phone_number": phone_number,
            "messaging_service_sid": messaging_service_sid
        }
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd inicjalizacji Twilio dla u≈ºytkownika {username}: {e}")
        return None

# Funkcja do wysy≈Çania SMS przez Twilio
async def send_sms(to_phone: str, message: str, twilio_config: dict, username: str = None) -> dict:
    """Wysy≈Ça SMS przez Twilio u≈ºywajƒÖc Messaging Service SID lub numeru telefonu"""
    if not twilio_config:
        raise HTTPException(status_code=500, detail="Twilio nie jest skonfigurowany")
    
    # Sprawd≈∫ limit SMS je≈õli podano username
    if username:
        limit_check = check_sms_limit(username)
        if not limit_check["allowed"]:
            raise HTTPException(status_code=429, detail=limit_check["message"])
    
    try:
        client = twilio_config["client"]
        messaging_service_sid = twilio_config.get("messaging_service_sid")
        phone_number = twilio_config.get("phone_number")
        
        # Wyczy≈õƒá numer telefonu (usu≈Ñ spacje, my≈õlniki)
        clean_phone = ''.join(filter(str.isdigit, to_phone))
        
        # Dodaj kod kraju je≈õli nie ma
        if not clean_phone.startswith('48') and len(clean_phone) == 9:
            clean_phone = '48' + clean_phone
        elif clean_phone.startswith('+'):
            clean_phone = clean_phone[1:]  # Usu≈Ñ +
        
        # Dodaj + na poczƒÖtku
        formatted_phone = '+' + clean_phone
        
        print(f"üì± Wysy≈Çanie SMS do: {formatted_phone}")
        print(f"üí¨ Tre≈õƒá: {message}")
        
        # U≈ºyj Messaging Service SID je≈õli dostƒôpny (preferowane), w przeciwnym razie u≈ºyj numeru telefonu
        if messaging_service_sid:
            print(f"üìû U≈ºywajƒÖc Messaging Service SID: {messaging_service_sid}")
            # Dok≈Çadnie taka sama sk≈Çadnia jak w przyk≈Çadzie Twilio SDK
            message_obj = client.messages.create(
                messaging_service_sid=messaging_service_sid,
                body=message,
                to=formatted_phone,
                status_callback=None  # Wy≈ÇƒÖcz callback URL
            )
        elif phone_number:
            print(f"üìû U≈ºywajƒÖc numeru telefonu: {phone_number}")
            message_obj = client.messages.create(
                body=message,
                from_=phone_number,
                to=formatted_phone
            )
        else:
            raise HTTPException(status_code=500, detail="Brak konfiguracji nadawcy (messaging_service_sid lub phone_number)")
        
        print(f"‚úÖ SMS wys≈Çany pomy≈õlnie. SID: {message_obj.sid}")
        
        # Zapisz informacjƒô o wys≈Çanym SMS do bazy danych i zwiƒôksz licznik
        if username:
            try:
                # Zapisz szczeg√≥≈Çy SMS do kolekcji miesiƒôcznej
                current_month = datetime.now().strftime("%Y-%m")
                sms_doc_ref = db.collection(username).document("SMS").collection(current_month).document()
                sms_data = {
                    "to_phone": to_phone,
                    "message": message,
                    "sid": message_obj.sid,
                    "sent_at": datetime.now(),
                    "status": "sent"
                }
                sms_doc_ref.set(sms_data)
                
                # Zwiƒôksz licznik SMS w ustawieniach u≈ºytkownika
                settings_doc_ref = db.collection(username).document("Dane")
                settings_doc = settings_doc_ref.get()
                if settings_doc.exists:
                    settings_data = settings_doc.to_dict()
                    if "messaging" not in settings_data:
                        settings_data["messaging"] = {}
                    if "smsCount" not in settings_data["messaging"]:
                        settings_data["messaging"]["smsCount"] = 0
                    
                    # Zwiƒôksz licznik o 1
                    settings_data["messaging"]["smsCount"] = settings_data["messaging"]["smsCount"] + 1
                    settings_data["updated_at"] = datetime.now().isoformat()
                    
                    # Zapisz zaktualizowane ustawienia
                    settings_doc_ref.set(settings_data)
                    print(f"üìä Licznik SMS zwiƒôkszony do: {settings_data['messaging']['smsCount']}")
                
                print(f"üìù Zapisano informacjƒô o SMS w bazie danych")
            except Exception as e:
                print(f"‚ö†Ô∏è B≈ÇƒÖd zapisywania SMS do bazy danych: {str(e)}")
        
        return {
            "success": True,
            "message": "SMS zosta≈Ç wys≈Çany pomy≈õlnie",
            "sid": message_obj.sid
        }
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd wysy≈Çania SMS: {str(e)}")
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd wysy≈Çania SMS: {str(e)}")

# Funkcja do generowania unikalnego kodu recenzji
def generate_review_code():
    """Generuje unikalny kod recenzji (10 znak√≥w alfanumerycznych)"""
    alphabet = string.ascii_lowercase + string.digits
    return ''.join(secrets.choice(alphabet) for _ in range(10))

# Funkcja do wysy≈Çania emaili kontaktowych
async def send_contact_email(contact_data: ContactFormRequest) -> dict:
    """Wysy≈Ça email kontaktowy na adres kontakt@next-reviews-booster.com"""
    try:
        # Konfiguracja SMTP dla konta kontakt@next-reviews-booster.com
        smtp_server = os.getenv("SMTP_SERVER")
        smtp_port_str = os.getenv("SMTP_PORT")
        smtp_username = os.getenv("SMTP_USERNAME")
        smtp_password = os.getenv("SMTP_PASSWORD")
        
        # Sprawd≈∫ czy wszystkie zmienne ≈õrodowiskowe sƒÖ ustawione
        if not smtp_server:
            raise ValueError("SMTP_SERVER nie jest ustawiony")
        if not smtp_port_str:
            raise ValueError("SMTP_PORT nie jest ustawiony")
        if not smtp_username:
            raise ValueError("SMTP_USERNAME nie jest ustawiony")
        if not smtp_password:
            raise ValueError("SMTP_PASSWORD nie jest ustawiony")
        
        # Konwertuj port na int
        try:
            smtp_port = int(smtp_port_str)
        except ValueError:
            raise ValueError(f"SMTP_PORT musi byƒá liczbƒÖ, otrzymano: {smtp_port_str}")
        
        # Adres docelowy
        to_email = "kontakt@next-reviews-booster.com"
        
        # Przygotuj wiadomo≈õƒá email
        msg = MIMEMultipart()
        msg['From'] = smtp_username
        msg['To'] = to_email
        msg['Subject'] = f"Nowa wiadomo≈õƒá kontaktowa od {contact_data.name}"
        
        # Tre≈õƒá wiadomo≈õci
        body = f"""
Nowa wiadomo≈õƒá z formularza kontaktowego:

Imiƒô i nazwisko: {contact_data.name}
Email: {contact_data.email}
Firma: {contact_data.company if contact_data.company else 'Nie podano'}
Data: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

Wiadomo≈õƒá:
{contact_data.message}

---
Wiadomo≈õƒá wys≈Çana z formularza kontaktowego na stronie next-reviews-booster.com
"""
        
        msg.attach(MIMEText(body, 'plain', 'utf-8'))
        
        # Wy≈õlij email
        print(f"üìß Wysy≈Çanie emaila kontaktowego od: {contact_data.name}")
        print(f"üìß SMTP Server: {smtp_server}:{smtp_port}")
        
        # U≈ºyj SMTP_SSL dla portu 465 (SSL/TLS)
        if smtp_port == 465:
            server = smtplib.SMTP_SSL(smtp_server, smtp_port)
        else:
            server = smtplib.SMTP(smtp_server, smtp_port)
            server.starttls()
        
        server.login(smtp_username, smtp_password)
        
        text = msg.as_string()
        server.sendmail(smtp_username, to_email, text)
        server.quit()
        
        print(f"‚úÖ Email kontaktowy wys≈Çany pomy≈õlnie od: {contact_data.name}")
        
        return {
            "success": True,
            "message": "Wiadomo≈õƒá zosta≈Ça wys≈Çana pomy≈õlnie. Odpowiemy najszybciej jak to mo≈ºliwe."
        }
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd wysy≈Çania emaila kontaktowego: {str(e)}")
        import traceback
        traceback.print_exc()
        
        # W przypadku b≈Çƒôdu, zapisz do log√≥w jako backup
        print("=" * 50)
        print("B≈ÅƒÑD WYSY≈ÅANIA EMAILA - ZAPISYWANIE DO LOG√ìW")
        print("=" * 50)
        print(f"Od: {contact_data.name} <{contact_data.email}>")
        if contact_data.company:
            print(f"Firma: {contact_data.company}")
        print(f"Data: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print("-" * 50)
        print("Wiadomo≈õƒá:")
        print(contact_data.message)
        print("-" * 50)
        print(f"B≈ÇƒÖd SMTP: {str(e)}")
        print("=" * 50)
        
        return {
            "success": True,
            "message": "Wiadomo≈õƒá zosta≈Ça zapisana. Odpowiemy najszybciej jak to mo≈ºliwe."
        }

# Funkcja do wysy≈Çania emaili z powiadomieniami o nowych opiniach
async def send_review_notification_email(owner_email: str, client_name: str, stars: int, review_text: str, company_name: str) -> dict:
    """Wysy≈Ça email z powiadomieniem o nowej opinii"""
    try:
        # Konfiguracja SMTP
        smtp_server = os.getenv("SMTP_SERVER")
        smtp_port_str = os.getenv("SMTP_PORT")
        smtp_username = os.getenv("SMTP_USERNAME")
        smtp_password = os.getenv("SMTP_PASSWORD")
        
        # Sprawd≈∫ czy wszystkie zmienne ≈õrodowiskowe sƒÖ ustawione
        if not smtp_server:
            raise ValueError("SMTP_SERVER nie jest ustawiony")
        if not smtp_port_str:
            raise ValueError("SMTP_PORT nie jest ustawiony")
        if not smtp_username:
            raise ValueError("SMTP_USERNAME nie jest ustawiony")
        if not smtp_password:
            raise ValueError("SMTP_PASSWORD nie jest ustawiony")
        
        # Konwertuj port na int
        try:
            smtp_port = int(smtp_port_str)
        except ValueError:
            raise ValueError(f"SMTP_PORT musi byƒá liczbƒÖ, otrzymano: {smtp_port_str}")
        
        # Przygotuj wiadomo≈õƒá email
        msg = MIMEMultipart()
        msg['From'] = smtp_username
        msg['To'] = owner_email
        msg['Subject'] = f"‚≠ê Nowa opinia od {client_name} - {stars} gwiazdek"
        
        # Przygotuj tre≈õƒá w zale≈ºno≈õci od oceny
        stars_emoji = "‚≠ê" * stars
        if stars >= 4:
            emoji = "üéâ"
            mood = "≈öwietna opinia!"
        elif stars == 3:
            emoji = "üìù"
            mood = "Nowa opinia"
        else:
            emoji = "‚ö†Ô∏è"
            mood = "Opinia wymagajƒÖca uwagi"
        
        # Tre≈õƒá wiadomo≈õci
        body = f"""
{emoji} {mood}

Drogi/a {company_name},

Otrzyma≈Çe≈õ/a≈õ nowƒÖ opiniƒô od klienta:

üë§ Klient: {client_name}
{stars_emoji} Ocena: {stars}/5 gwiazdek
üìÖ Data: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

üí¨ Tre≈õƒá opinii:
{review_text if review_text else "Brak tre≈õci recenzji"}

---
Mo≈ºesz zobaczyƒá wszystkie opinie w swoim panelu administracyjnym:
https://next-reviews-booster.com/dashboard

Zesp√≥≈Ç NEXT reviews BOOSTER
"""
        
        msg.attach(MIMEText(body, 'plain', 'utf-8'))
        
        # Wy≈õlij email
        print(f"üìß Wysy≈Çanie powiadomienia email o opinii od: {client_name}")
        print(f"üìß Do: {owner_email}")
        print(f"üìß SMTP Server: {smtp_server}:{smtp_port}")
        
        # U≈ºyj SMTP_SSL dla portu 465 (SSL/TLS)
        if smtp_port == 465:
            server = smtplib.SMTP_SSL(smtp_server, smtp_port)
        else:
            server = smtplib.SMTP(smtp_server, smtp_port)
            server.starttls()
        
        server.login(smtp_username, smtp_password)
        
        text = msg.as_string()
        server.sendmail(smtp_username, owner_email, text)
        server.quit()
        
        print(f"‚úÖ Email z powiadomieniem o opinii wys≈Çany pomy≈õlnie do: {owner_email}")
        
        return {
            "success": True,
            "message": "Email z powiadomieniem zosta≈Ç wys≈Çany"
        }
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd wysy≈Çania emaila z powiadomieniem: {str(e)}")
        import traceback
        traceback.print_exc()
        
        # W przypadku b≈Çƒôdu, zapisz do log√≥w jako backup
        print("=" * 50)
        print("B≈ÅƒÑD WYSY≈ÅANIA EMAILA Z POWIADOMIENIEM - ZAPISYWANIE DO LOG√ìW")
        print("=" * 50)
        print(f"Do: {owner_email}")
        print(f"Klient: {client_name}")
        print(f"Ocena: {stars} gwiazdek")
        print(f"Data: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print("-" * 50)
        print("Tre≈õƒá opinii:")
        print(review_text)
        print("-" * 50)
        print(f"B≈ÇƒÖd SMTP: {str(e)}")
        print("-" * 50)
        print("Sprawd≈∫ zmienne ≈õrodowiskowe:")
        print(f"SMTP_SERVER: {os.getenv('SMTP_SERVER', 'NIE USTAWIONY')}")
        print(f"SMTP_PORT: {os.getenv('SMTP_PORT', 'NIE USTAWIONY')}")
        print(f"SMTP_USERNAME: {os.getenv('SMTP_USERNAME', 'NIE USTAWIONY')}")
        print(f"SMTP_PASSWORD: {'USTAWIONY' if os.getenv('SMTP_PASSWORD') else 'NIE USTAWIONY'}")
        print("=" * 50)
        
        return {
            "success": False,
            "message": "B≈ÇƒÖd wysy≈Çania emaila z powiadomieniem"
        }


# Funkcja do generowania kodu QR
def generate_qr_code(data: str, size: int = 200) -> bytes:
    """Generuje kod QR jako bytes z lepszƒÖ konfiguracjƒÖ zgodnie z dokumentacjƒÖ"""
    # Oblicz box_size na podstawie ≈ºƒÖdanego rozmiaru
    # Dla wersji 1 (21x21) z border=4, ca≈Çkowity rozmiar to (21 + 2*4) * box_size
    # Dla rozmiaru 200px: box_size = 200 / (21 + 8) = ~6.9, zaokrƒÖglamy do 7
    box_size = max(4, size // 30)  # Minimum 4px na box
    
    qr = qrcode.QRCode(
        version=None,  # Automatyczny wyb√≥r wersji zgodnie z dokumentacjƒÖ
        error_correction=qrcode.constants.ERROR_CORRECT_M,  # 15% korekta b≈Çƒôd√≥w (domy≈õlne)
        box_size=box_size,
        border=4,  # Minimalny border zgodnie ze specyfikacjƒÖ
    )
    qr.add_data(data)
    qr.make(fit=True)
    
    # Generuj obraz z lepszymi kolorami
    img = qr.make_image(
        fill_color="black", 
        back_color="white"
    )
    
    # Je≈õli obraz jest za du≈ºy, przeskaluj go
    if img.size[0] > size:
        # U≈ºyj LANCZOS zamiast ANTIALIAS (nowsze wersje Pillow)
        from PIL import Image
        img = img.resize((size, size), Image.Resampling.LANCZOS)
    
    # Konwertuj do bytes z optymalizacjƒÖ
    img_bytes = io.BytesIO()
    img.save(img_bytes, format='PNG', optimize=True)
    img_bytes.seek(0)
    
    return img_bytes.getvalue()

# Funkcja do sprawdzania i wysy≈Çania cyklicznych przypomnie≈Ñ SMS
async def check_and_send_reminders():
    """Sprawd≈∫ wszystkich klient√≥w i wy≈õlij przypomnienia SMS je≈õli potrzebne"""
    print("üîÑ Rozpoczƒôcie sprawdzania przypomnie≈Ñ SMS...")
    
    if not db:
        print("‚ùå Firebase nie jest skonfigurowany")
        return
    
    try:
        # Pobierz wszystkie kolekcje u≈ºytkownik√≥w
        collections = db.collections()
        total_reminders_sent = 0
        
        for collection in collections:
            collection_name = collection.id
            
            # Pomi≈Ñ kolekcje systemowe
            if collection_name in ["temp_clients"]:
                continue
            
            print(f"üîç Sprawdzanie kolekcji: {collection_name}")
            
            # Sprawd≈∫ czy u≈ºytkownik ma w≈ÇƒÖczone automatyczne przypomnienia
            try:
                settings_doc = db.collection(collection_name).document("Dane").get()
                if not settings_doc.exists:
                    print(f"‚ö†Ô∏è Brak ustawie≈Ñ dla u≈ºytkownika: {collection_name}")
                    continue
                
                settings_data = settings_doc.to_dict()
                
                # Sprawd≈∫ czy autoSendEnabled jest w≈ÇƒÖczone
                auto_send_enabled = False
                reminder_frequency = 7  # domy≈õlnie 7 dni
                
                if "messaging" in settings_data:
                    messaging = settings_data["messaging"]
                    auto_send_enabled = messaging.get("autoSendEnabled", False)
                    reminder_frequency = messaging.get("reminderFrequency", 7)
                
                if not auto_send_enabled:
                    print(f"‚è≠Ô∏è Automatyczne przypomnienia wy≈ÇƒÖczone dla: {collection_name}")
                    continue
                
                # Sprawd≈∫ czy to odpowiednia godzina dla wysy≈Çki SMS
                send_time = messaging.get("sendTime", {"hour": 10, "minute": 0}) if "messaging" in settings_data else {"hour": 10, "minute": 0}
                current_time = datetime.now()
                current_hour = current_time.hour
                current_minute = current_time.minute
                
                target_hour = send_time.get("hour", 10)
                target_minute = send_time.get("minute", 0)
                
                # Sprawd≈∫ czy jeste≈õmy w oknie 1 godziny od ustalonej godziny wysy≈Çki
                # (np. je≈õli ustawiono 10:00, to wysy≈Çaj miƒôdzy 10:00 a 10:59)
                if current_hour != target_hour:
                    print(f"‚è∞ Nie pora na wysy≈Çkƒô dla {collection_name}. Aktualna: {current_hour:02d}:{current_minute:02d}, Ustawiona: {target_hour:02d}:{target_minute:02d}")
                    continue
                
                print(f"‚úÖ Automatyczne przypomnienia w≈ÇƒÖczone (czƒôstotliwo≈õƒá: {reminder_frequency} dni, godzina: {target_hour:02d}:{target_minute:02d})")
                
                # Pobierz konfiguracjƒô Twilio
                twilio_config = get_twilio_client_for_user(collection_name)
                if not twilio_config:
                    print(f"‚ö†Ô∏è Brak konfiguracji Twilio dla u≈ºytkownika: {collection_name}")
                    continue
                
                # Pobierz szablon wiadomo≈õci i nazwƒô firmy
                message_template = """Dzie≈Ñ dobry!

Chcia≈Çbym przypomnieƒá o mo≈ºliwo≈õci wystawienia opinii o naszych us≈Çugach. 
Wasza opinia jest dla nas bardzo wa≈ºna i pomo≈ºe innym klientom w podjƒôciu decyzji.

Link do wystawienia opinii: [LINK]

Z g√≥ry dziƒôkujƒô za po≈õwiƒôcony czas!

Z powa≈ºaniem,
[NAZWA_FIRMY]"""
                company_name = "Twoja Firma"
                
                if "messaging" in settings_data and "messageTemplate" in settings_data["messaging"]:
                    message_template = settings_data["messaging"]["messageTemplate"]
                if "userData" in settings_data and "companyName" in settings_data["userData"]:
                    company_name = settings_data["userData"]["companyName"]
                
                # Pobierz wszystkich klient√≥w tej kolekcji (pomijamy dokument "Dane")
                docs = collection.stream()
                
                for doc in docs:
                    # Pomi≈Ñ dokument "Dane"
                    if doc.id == "Dane":
                        continue
                    
                    client_data = doc.to_dict()
                    client_id = doc.id
                    
                    # Sprawd≈∫ czy klient spe≈Çnia warunki do wys≈Çania przypomnienia
                    review_status = client_data.get("review_status", "not_sent")
                    phone = client_data.get("phone", "")
                    review_code = client_data.get("review_code", "")
                    client_name = client_data.get("name", "")
                    sms_count = client_data.get("sms_count", 0)
                    
                    # Pomi≈Ñ klient√≥w bez numeru telefonu lub kodu recenzji
                    if not phone or not review_code:
                        continue
                    
                    # Pomi≈Ñ klient√≥w kt√≥rzy ju≈º uko≈Ñczyli recenzjƒô
                    if review_status == "completed":
                        continue
                    
                    # Pomi≈Ñ klient√≥w kt√≥rzy osiƒÖgnƒôli limit SMS
                    if sms_count >= 2:
                        continue
                    
                    # Sprawd≈∫ czy minƒÖ≈Ç odpowiedni czas od ostatniego SMS
                    last_sms_sent = client_data.get("last_sms_sent")
                    created_at = client_data.get("created_at")
                    
                    now = datetime.now()
                    should_send = False
                    
                    # Konwertuj Firebase Timestamp na datetime je≈õli potrzeba
                    last_sms_sent = convert_firebase_timestamp_to_naive(last_sms_sent)
                    created_at = convert_firebase_timestamp_to_naive(created_at)
                    
                    print(f"üîç Sprawdzanie klienta: {client_name}")
                    print(f"   - Status: {review_status}")
                    print(f"   - Ostatni SMS: {last_sms_sent}")
                    print(f"   - Czƒôstotliwo≈õƒá: {reminder_frequency} dni")
                    
                    if review_status == "not_sent":
                        # Je≈õli nigdy nie wys≈Çano SMS, wy≈õlij pierwszy raz
                        if not last_sms_sent:
                            should_send = True
                            print(f"üì§ Pierwszy SMS dla: {client_name}")
                    elif review_status in ["sent", "opened"]:
                        # Je≈õli SMS by≈Ç wys≈Çany lub link by≈Ç otwarty, sprawd≈∫ czy minƒÖ≈Ç czas na przypomnienie
                        if last_sms_sent:
                            # U≈ºyj total_seconds() zamiast days dla dok≈Çadniejszego por√≥wnania
                            time_diff = now - last_sms_sent
                            hours_since_last_sms = time_diff.total_seconds() / 3600
                            days_since_last_sms = time_diff.days
                            
                            print(f"   - Godziny od ostatniego SMS: {hours_since_last_sms:.2f}")
                            print(f"   - Dni od ostatniego SMS: {days_since_last_sms}")
                            
                            # Dla czƒôstotliwo≈õci 1 dzie≈Ñ - sprawd≈∫ czy minƒô≈Ço co najmniej 24 godziny
                            if reminder_frequency == 1:
                                if hours_since_last_sms >= 24:
                                    should_send = True
                                    print(f"üîî Przypomnienie dla: {client_name} (ostatni SMS: {hours_since_last_sms:.1f} godzin temu)")
                            else:
                                # Dla innych czƒôstotliwo≈õci u≈ºywaj dni
                                if days_since_last_sms >= reminder_frequency:
                                    should_send = True
                                    print(f"üîî Przypomnienie dla: {client_name} (ostatni SMS: {days_since_last_sms} dni temu)")
                    
                    if should_send:
                        try:
                            # Przygotuj URL do recenzji
                            base_url = os.getenv("FRONTEND_URL", "https://next-reviews-booster-app.web.app")
                            review_url = f"{base_url}/review/{review_code}"
                            
                            # Przygotuj wiadomo≈õƒá
                            message = message_template.replace("[LINK]", review_url).replace("[NAZWA_FIRMY]", company_name)
                            
                            # Wy≈õlij SMS
                            print(f"üì± Wysy≈Çanie przypomnienia SMS do: {client_name} ({phone})")
                            result = await send_sms(phone, message, twilio_config, collection_name)
                            
                            # Zaktualizuj status klienta
                            doc_ref = db.collection(collection_name).document(client_id)
                            update_data = {
                                "last_sms_sent": now,
                                "updated_at": now,
                                "sms_count": sms_count + 1
                            }
                            
                            # Je≈õli to pierwszy SMS, zmie≈Ñ status na "sent"
                            if review_status == "not_sent":
                                update_data["review_status"] = "sent"
                            
                            doc_ref.update(update_data)
                            
                            total_reminders_sent += 1
                            print(f"‚úÖ Przypomnienie wys≈Çane do: {client_name}")
                            
                        except Exception as sms_error:
                            print(f"‚ùå B≈ÇƒÖd wysy≈Çania SMS do {client_name}: {str(sms_error)}")
                            continue
                
            except Exception as user_error:
                print(f"‚ùå B≈ÇƒÖd przetwarzania u≈ºytkownika {collection_name}: {str(user_error)}")
                continue
        
        print(f"‚úÖ Sprawdzanie zako≈Ñczone. Wys≈Çano {total_reminders_sent} przypomnie≈Ñ")
        return {"reminders_sent": total_reminders_sent}
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas sprawdzania przypomnie≈Ñ: {str(e)}")
        import traceback
        traceback.print_exc()
        return {"error": str(e)}

# Inicjalizacja schedulera
scheduler = BackgroundScheduler()

def run_async_check_and_send_reminders():
    """Wrapper do uruchamiania async funkcji w scheduler"""
    try:
        print(f"üïê [{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Uruchamianie schedulera przypomnie≈Ñ SMS...")
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        result = loop.run_until_complete(check_and_send_reminders())
        loop.close()
        print(f"‚úÖ [{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Scheduler zako≈Ñczony: {result}")
    except Exception as e:
        print(f"‚ùå [{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] B≈ÇƒÖd w schedulerze: {str(e)}")
        import traceback
        traceback.print_exc()

# Dodaj zadanie do schedulera - sprawdzaj co godzinƒô
scheduler.add_job(
    run_async_check_and_send_reminders,
    'interval',
    hours=1,
    id='check_reminders',
    name='Sprawdzanie i wysy≈Çanie przypomnie≈Ñ SMS',
    replace_existing=True
)

# Uruchom scheduler
scheduler.start()
print("‚úÖ Scheduler przypomnie≈Ñ SMS uruchomiony (sprawdzanie co godzinƒô)")

@app.get("/health", response_model=HealthResponse)
async def health_check():
    return HealthResponse(
        status="ok",
        message="next review booster API dzia≈Ça poprawnie! üöÄ",
        timestamp=datetime.now(),
        version="1.0.0"
    )

@app.get("/")
async def root():
    return {
        "message": "Witaj w next review booster API! üéâ",
        "version": "1.0.0",
        "docs": "/docs",
        "health": "/health"
    }

# Endpointy dla klient√≥w
@app.post("/clients/{username}", response_model=ClientResponse)
async def create_client(username: str, client_data: ClientCreate):
    """Dodaj nowego klienta do kolekcji u≈ºytkownika"""
    print(f"‚ûï Dodawanie klienta dla u≈ºytkownika: {username}")
    print(f"üìä Dane klienta: {client_data.dict()}")
    
    if not db:
        print("‚ùå Firebase nie jest skonfigurowany")
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    # Sprawd≈∫ uprawnienia u≈ºytkownika - Demo mo≈ºe mieƒá ograniczenia
    user_permission = get_user_permission_from_db(username)
    if user_permission == UserPermission.DEMO:
        print(f"‚ö†Ô∏è U≈ºytkownik {username} ma uprawnienia Demo - sprawdzanie limit√≥w")
        # Tutaj mo≈ºna dodaƒá logikƒô sprawdzania limit√≥w dla u≈ºytkownik√≥w Demo
        # Na przyk≈Çad: maksymalna liczba klient√≥w, ograniczenia funkcjonalno≈õci
    
    try:
        # Kolekcja nazywa siƒô tak jak username
        clients_ref = db.collection(username)
        print(f"üìÇ Kolekcja: {username}")
        
        # Dodaj timestampy i wygeneruj kod recenzji
        now = datetime.now()
        client_dict = client_data.dict()
        review_code = generate_review_code()
        client_dict.update({
            "created_at": now,
            "updated_at": now,
            "review_code": review_code,
            "review_status": "not_sent",
            "last_sms_sent": None,
            "sms_count": 0,
            "source": "CRM"
        })
        print(f"üìù Dane do zapisu: {client_dict}")
        print(f"üîë Wygenerowany kod recenzji: {review_code}")
        
        # Dodaj klienta do Firestore
        doc_ref = clients_ref.add(client_dict)[1]
        print(f"‚úÖ Klient dodany z ID: {doc_ref.id}")
        
        # Pobierz dodanego klienta
        doc = doc_ref.get()
        client_data_dict = doc.to_dict()
        client_data_dict["id"] = doc.id
        print(f"üìñ Odczytane dane: {client_data_dict}")
        
        # Konwertuj Firebase Timestamp na datetime
        if "created_at" in client_data_dict:
            client_data_dict["created_at"] = convert_firebase_timestamp_to_naive(client_data_dict["created_at"])
        if "updated_at" in client_data_dict:
            client_data_dict["updated_at"] = convert_firebase_timestamp_to_naive(client_data_dict["updated_at"])
        if "last_sms_sent" in client_data_dict:
            client_data_dict["last_sms_sent"] = convert_firebase_timestamp_to_naive(client_data_dict["last_sms_sent"])
        
        # Upewnij siƒô, ≈ºe last_sms_sent istnieje
        if "last_sms_sent" not in client_data_dict:
            client_data_dict["last_sms_sent"] = None
        
        return ClientResponse(**client_data_dict)
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas dodawania klienta: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas dodawania klienta: {str(e)}")

@app.get("/clients/{username}", response_model=ClientListResponse)
async def get_clients(username: str):
    """Pobierz wszystkich klient√≥w u≈ºytkownika"""
    print(f"üîç Pobieranie klient√≥w dla u≈ºytkownika: {username}")
    
    if not db:
        print("‚ùå Firebase nie jest skonfigurowany")
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    # Upewnij siƒô, ≈ºe u≈ºytkownik istnieje w bazie danych
    ensure_user_exists(username)
    
    try:
        print(f"üìÇ Pr√≥ba dostƒôpu do kolekcji: {username}")
        clients_ref = db.collection(username)
        docs = clients_ref.stream()
        
        clients = []
        doc_count = 0
        for doc in docs:
            doc_count += 1
            print(f"üìÑ Dokument {doc_count}: {doc.id}")
            
            # Pomi≈Ñ dokument "Dane" - to sƒÖ ustawienia u≈ºytkownika, nie klient
            if doc.id == "Dane":
                print(f"‚è≠Ô∏è Pomijanie dokumentu 'Dane' (ustawienia u≈ºytkownika)")
                continue
            
            client_data = doc.to_dict()
            client_data["id"] = doc.id
            print(f"üìä Dane klienta: {client_data}")
            
            try:
                # Konwertuj Firebase Timestamp na datetime
                if "created_at" in client_data:
                    client_data["created_at"] = convert_firebase_timestamp_to_naive(client_data["created_at"])
                if "updated_at" in client_data:
                    client_data["updated_at"] = convert_firebase_timestamp_to_naive(client_data["updated_at"])
                if "last_sms_sent" in client_data:
                    client_data["last_sms_sent"] = convert_firebase_timestamp_to_naive(client_data["last_sms_sent"])
                
                # Upewnij siƒô, ≈ºe wszystkie wymagane pola sƒÖ obecne
                if "note" not in client_data:
                    client_data["note"] = ""
                if "stars" not in client_data:
                    client_data["stars"] = 0
                if "review" not in client_data:
                    client_data["review"] = ""
                if "review_code" not in client_data:
                    client_data["review_code"] = ""
                if "review_status" not in client_data:
                    client_data["review_status"] = "not_sent"
                if "last_sms_sent" not in client_data:
                    client_data["last_sms_sent"] = None
                if "sms_count" not in client_data:
                    client_data["sms_count"] = 0
                if "source" not in client_data:
                    client_data["source"] = "CRM"
                
                client_response = ClientResponse(**client_data)
                clients.append(client_response)
                print(f"‚úÖ Klient {doc_count} dodany do listy")
            except Exception as validation_error:
                print(f"‚ùå B≈ÇƒÖd walidacji dla klienta {doc_count}: {validation_error}")
                print(f"üìä Problemowe dane: {client_data}")
                # Kontynuuj z nastƒôpnym dokumentem
                continue
        
        print(f"‚úÖ Znaleziono {len(clients)} klient√≥w")
        return ClientListResponse(clients=clients, total=len(clients))
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas pobierania klient√≥w: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas pobierania klient√≥w: {str(e)}")

@app.get("/clients/{username}/{client_id}", response_model=ClientResponse)
async def get_client(username: str, client_id: str):
    """Pobierz konkretnego klienta"""
    if not db:
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        doc_ref = db.collection(username).document(client_id)
        doc = doc_ref.get()
        
        if not doc.exists:
            raise HTTPException(status_code=404, detail="Klient nie zosta≈Ç znaleziony")
        
        client_data = doc.to_dict()
        client_data["id"] = doc.id
        
        # Konwertuj Firebase Timestamp na datetime
        if "created_at" in client_data and hasattr(client_data["created_at"], 'to_pydatetime'):
            client_data["created_at"] = client_data["created_at"].to_pydatetime()
        if "updated_at" in client_data and hasattr(client_data["updated_at"], 'to_pydatetime'):
            client_data["updated_at"] = client_data["updated_at"].to_pydatetime()
        if "last_sms_sent" in client_data and client_data["last_sms_sent"] and hasattr(client_data["last_sms_sent"], 'to_pydatetime'):
            client_data["last_sms_sent"] = client_data["last_sms_sent"].to_pydatetime()
        
        # Upewnij siƒô, ≈ºe last_sms_sent istnieje
        if "last_sms_sent" not in client_data:
            client_data["last_sms_sent"] = None
        
        return ClientResponse(**client_data)
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas pobierania klienta: {str(e)}")

@app.put("/clients/{username}/{client_id}", response_model=ClientResponse)
async def update_client(username: str, client_id: str, client_data: ClientUpdate):
    """Zaktualizuj klienta"""
    if not db:
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        doc_ref = db.collection(username).document(client_id)
        doc = doc_ref.get()
        
        if not doc.exists:
            raise HTTPException(status_code=404, detail="Klient nie zosta≈Ç znaleziony")
        
        # Przygotuj dane do aktualizacji (tylko nie-None warto≈õci)
        update_data = {k: v for k, v in client_data.dict().items() if v is not None}
        update_data["updated_at"] = datetime.now()
        
        # Zaktualizuj dokument
        doc_ref.update(update_data)
        
        # Pobierz zaktualizowany dokument
        updated_doc = doc_ref.get()
        client_data_dict = updated_doc.to_dict()
        client_data_dict["id"] = updated_doc.id
        
        # Konwertuj Firebase Timestamp na datetime
        if "created_at" in client_data_dict:
            client_data_dict["created_at"] = convert_firebase_timestamp_to_naive(client_data_dict["created_at"])
        if "updated_at" in client_data_dict:
            client_data_dict["updated_at"] = convert_firebase_timestamp_to_naive(client_data_dict["updated_at"])
        if "last_sms_sent" in client_data_dict:
            client_data_dict["last_sms_sent"] = convert_firebase_timestamp_to_naive(client_data_dict["last_sms_sent"])
        
        # Upewnij siƒô, ≈ºe last_sms_sent istnieje
        if "last_sms_sent" not in client_data_dict:
            client_data_dict["last_sms_sent"] = None
        
        return ClientResponse(**client_data_dict)
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas aktualizacji klienta: {str(e)}")

@app.delete("/clients/{username}/{client_id}")
async def delete_client(username: str, client_id: str):
    """Usu≈Ñ klienta"""
    if not db:
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        doc_ref = db.collection(username).document(client_id)
        doc = doc_ref.get()
        
        if not doc.exists:
            raise HTTPException(status_code=404, detail="Klient nie zosta≈Ç znaleziony")
        
        # Usu≈Ñ dokument
        doc_ref.delete()
        
        return {"message": "Klient zosta≈Ç usuniƒôty pomy≈õlnie"}
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas usuwania klienta: {str(e)}")

# Endpointy dla ustawie≈Ñ u≈ºytkownika
@app.get("/settings/{username}", response_model=UserSettingsResponse)
async def get_user_settings(username: str):
    """Pobierz ustawienia u≈ºytkownika"""
    print(f"‚öôÔ∏è Pobieranie ustawie≈Ñ dla u≈ºytkownika: {username}")
    
    if not db:
        print("‚ùå Firebase nie jest skonfigurowany")
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        doc_ref = db.collection(username).document("Dane")
        doc = doc_ref.get()
        
        if doc.exists:
            settings_data = doc.to_dict()
            print(f"‚úÖ Znaleziono ustawienia: {settings_data}")
            return UserSettingsResponse(settings=UserSettings(**settings_data))
        else:
            print("‚ÑπÔ∏è Brak ustawie≈Ñ, tworzƒô nowy rekord u≈ºytkownika")
            # Utw√≥rz nowy rekord u≈ºytkownika z domy≈õlnymi danymi
            ensure_user_exists(username)
            
            # Pobierz nowo utworzone ustawienia
            doc = doc_ref.get()
            if doc.exists:
                settings_data = doc.to_dict()
                print(f"‚úÖ Utworzono nowy rekord u≈ºytkownika: {settings_data}")
                return UserSettingsResponse(settings=UserSettings(**settings_data))
            else:
                # Fallback - zwr√≥ƒá domy≈õlne ustawienia
                default_settings = UserSettings(
                    userData=UserData(
                        name="",
                        surname="",
                        email="",
                        companyName="",
                        googleCard=""
                    ),
            messaging=MessagingSettings(
                reminderFrequency=7,
                messageTemplate="""Bardzo prosimy o zostawienie opinii o naszych us≈Çugach: [LINK]
Wasza opinia ma dla nas ogromne znaczenie i pomo≈ºe kolejnym klientom w wyborze.

Dziƒôkujemy!""",
                autoSendEnabled=False,
                sendTime={"hour": 10, "minute": 0},
                smsLimit=get_sms_limit_for_permission(UserPermission.DEMO)
            ),
                    twilio=TwilioSettings(
                        account_sid="ACfc0d69a38f5b328bc7783fa5829336b2",
                        auth_token="3d5761074605ac590f0c18494820d15f",
                        phone_number="",
                        messaging_service_sid="MG12792d6acd38447e77756a5ceb2c75f1"
                    ),
                    permission=UserPermission.DEMO
                )
                return UserSettingsResponse(settings=default_settings)
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas pobierania ustawie≈Ñ: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas pobierania ustawie≈Ñ: {str(e)}")

@app.put("/settings/{username}")
async def save_user_settings(username: str, settings: UserSettings):
    """Zapisz ustawienia u≈ºytkownika"""
    print(f"üíæ Zapisywanie ustawie≈Ñ dla u≈ºytkownika: {username}")
    print(f"üìä Dane ustawie≈Ñ: {settings.dict()}")
    
    if not db:
        print("‚ùå Firebase nie jest skonfigurowany")
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        doc_ref = db.collection(username).document("Dane")
        
        # Dodaj timestamp
        settings_dict = settings.dict()
        settings_dict.update({
            "updated_at": datetime.now()
        })
        
        # Zapisz do Firestore
        doc_ref.set(settings_dict)
        print(f"‚úÖ Ustawienia zapisane pomy≈õlnie")
        
        return {"message": "Ustawienia zosta≈Çy zapisane pomy≈õlnie"}
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas zapisywania ustawie≈Ñ: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas zapisywania ustawie≈Ñ: {str(e)}")

# Endpointy do zarzƒÖdzania uprawnieniami u≈ºytkownik√≥w
class PermissionUpdateRequest(BaseModel):
    permission: UserPermission

class PermissionResponse(BaseModel):
    username: str
    permission: UserPermission
    message: str

@app.put("/admin/permissions/{username}", response_model=PermissionResponse)
async def update_user_permission(username: str, permission_data: PermissionUpdateRequest, admin_username: str = None):
    """Zaktualizuj uprawnienia u≈ºytkownika (tylko dla admin√≥w)"""
    print(f"üîê Aktualizacja uprawnie≈Ñ dla u≈ºytkownika: {username}")
    print(f"üîê Nowe uprawnienia: {permission_data.permission}")
    print(f"üîê Admin wykonujƒÖcy akcjƒô: {admin_username}")
    
    if not db:
        print("‚ùå Firebase nie jest skonfigurowany")
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    # Sprawd≈∫ uprawnienia admina (je≈õli podano)
    if admin_username and not check_user_permission(admin_username, UserPermission.ADMIN):
        print(f"‚ùå U≈ºytkownik {admin_username} nie ma uprawnie≈Ñ administratora")
        raise HTTPException(status_code=403, detail="Brak uprawnie≈Ñ administratora")
    
    try:
        # Sprawd≈∫ czy u≈ºytkownik istnieje
        doc_ref = db.collection(username).document("Dane")
        doc = doc_ref.get()
        
        if not doc.exists:
            print(f"‚ùå U≈ºytkownik {username} nie istnieje")
            raise HTTPException(status_code=404, detail="U≈ºytkownik nie zosta≈Ç znaleziony")
        
        # Pobierz obecne ustawienia
        settings_data = doc.to_dict()
        settings = UserSettings(**settings_data)
        
        # Zaktualizuj uprawnienia
        settings.permission = permission_data.permission
        
        # Zaktualizuj limit SMS na podstawie nowych uprawnie≈Ñ
        new_sms_limit = get_sms_limit_for_permission(permission_data.permission)
        settings.messaging.smsLimit = new_sms_limit
        print(f"üìä Zaktualizowano limit SMS dla {username}: {new_sms_limit}")
        
        # Zapisz zaktualizowane ustawienia
        settings_dict = settings.dict()
        settings_dict.update({
            "updated_at": datetime.now()
        })
        
        doc_ref.set(settings_dict)
        print(f"‚úÖ Uprawnienia zaktualizowane pomy≈õlnie dla {username}: {permission_data.permission}")
        
        return PermissionResponse(
            username=username,
            permission=permission_data.permission,
            message=f"Uprawnienia u≈ºytkownika {username} zosta≈Çy zaktualizowane na {permission_data.permission}"
        )
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas aktualizacji uprawnie≈Ñ: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas aktualizacji uprawnie≈Ñ: {str(e)}")

@app.get("/admin/permissions/{username}", response_model=PermissionResponse)
async def get_user_permission(username: str):
    """Pobierz uprawnienia u≈ºytkownika"""
    print(f"üîç Sprawdzanie uprawnie≈Ñ dla u≈ºytkownika: {username}")
    
    if not db:
        print("‚ùå Firebase nie jest skonfigurowany")
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        doc_ref = db.collection(username).document("Dane")
        doc = doc_ref.get()
        
        if not doc.exists:
            print(f"‚ùå U≈ºytkownik {username} nie istnieje")
            raise HTTPException(status_code=404, detail="U≈ºytkownik nie zosta≈Ç znaleziony")
        
        settings_data = doc.to_dict()
        settings = UserSettings(**settings_data)
        
        print(f"‚úÖ Uprawnienia u≈ºytkownika {username}: {settings.permission}")
        
        return PermissionResponse(
            username=username,
            permission=settings.permission,
            message=f"Uprawnienia u≈ºytkownika {username}: {settings.permission}"
        )
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas pobierania uprawnie≈Ñ: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas pobierania uprawnie≈Ñ: {str(e)}")

class UserPermissionInfo(BaseModel):
    username: str
    permission: UserPermission
    permission_level: int
    can_manage_clients: bool
    can_send_sms: bool
    can_access_admin: bool
    limits: dict

@app.get("/user-permission-info/{username}", response_model=UserPermissionInfo)
async def get_user_permission_info(username: str):
    """Pobierz szczeg√≥≈Çowe informacje o uprawnieniach u≈ºytkownika"""
    print(f"üîç Sprawdzanie szczeg√≥≈Çowych uprawnie≈Ñ dla u≈ºytkownika: {username}")
    
    if not db:
        print("‚ùå Firebase nie jest skonfigurowany")
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        user_permission = get_user_permission_from_db(username)
        
        # Hierarchia uprawnie≈Ñ
        permission_hierarchy = {
            UserPermission.ADMIN: 4,
            UserPermission.PROFESSIONAL: 3,
            UserPermission.STARTER: 2,
            UserPermission.DEMO: 1
        }
        
        permission_level = permission_hierarchy.get(user_permission, 1)
        
        # Okre≈õl mo≈ºliwo≈õci na podstawie uprawnie≈Ñ
        can_manage_clients = user_permission in [UserPermission.ADMIN, UserPermission.PROFESSIONAL, UserPermission.STARTER]
        can_send_sms = user_permission in [UserPermission.ADMIN, UserPermission.PROFESSIONAL, UserPermission.STARTER]
        can_access_admin = user_permission == UserPermission.ADMIN
        
        # Okre≈õl limity na podstawie uprawnie≈Ñ
        limits = {}
        if user_permission == UserPermission.DEMO:
            limits = {
                "max_clients": 5,
                "max_sms_per_month": 10,
                "features": ["basic_reviews"]
            }
        elif user_permission == UserPermission.STARTER:
            limits = {
                "max_clients": 50,
                "max_sms_per_month": 100,
                "features": ["basic_reviews", "sms_reminders"]
            }
        elif user_permission == UserPermission.PROFESSIONAL:
            limits = {
                "max_clients": 500,
                "max_sms_per_month": 1000,
                "features": ["basic_reviews", "sms_reminders", "advanced_analytics"]
            }
        elif user_permission == UserPermission.ADMIN:
            limits = {
                "max_clients": -1,  # Bez limitu
                "max_sms_per_month": -1,  # Bez limitu
                "features": ["all"]
            }
        
        print(f"‚úÖ Uprawnienia u≈ºytkownika {username}: {user_permission} (poziom {permission_level})")
        
        return UserPermissionInfo(
            username=username,
            permission=user_permission,
            permission_level=permission_level,
            can_manage_clients=can_manage_clients,
            can_send_sms=can_send_sms,
            can_access_admin=can_access_admin,
            limits=limits
        )
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas pobierania informacji o uprawnieniach: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas pobierania informacji o uprawnieniach: {str(e)}")

@app.post("/admin/migrate-user-permissions")
async def migrate_user_permissions():
    """Migruj istniejƒÖcych u≈ºytkownik√≥w - ustaw im uprawnienia Demo je≈õli nie majƒÖ uprawnie≈Ñ"""
    print(f"üîÑ Rozpoczynanie migracji uprawnie≈Ñ u≈ºytkownik√≥w")
    
    if not db:
        print("‚ùå Firebase nie jest skonfigurowany")
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        migrated_count = 0
        skipped_count = 0
        
        # Pobierz wszystkie kolekcje (u≈ºytkownik√≥w)
        collections = db.collections()
        
        for collection in collections:
            collection_name = collection.id
            print(f"üîç Sprawdzanie kolekcji: {collection_name}")
            
            # Sprawd≈∫ czy to jest kolekcja u≈ºytkownika (nie systemowa)
            if collection_name in ["temp_clients", "Dane"]:
                print(f"‚è≠Ô∏è Pomijanie kolekcji systemowej: {collection_name}")
                continue
            
            # Sprawd≈∫ czy u≈ºytkownik ma dokument "Dane"
            doc_ref = collection.document("Dane")
            doc = doc_ref.get()
            
            if doc.exists:
                settings_data = doc.to_dict()
                
                # Sprawd≈∫ czy ma ju≈º uprawnienia
                if "permission" not in settings_data:
                    print(f"üîÑ Migracja u≈ºytkownika: {collection_name}")
                    
                    # Dodaj uprawnienia Demo
                    settings_data["permission"] = UserPermission.DEMO
                    settings_data["updated_at"] = datetime.now()
                    
                    # Zapisz zaktualizowane ustawienia
                    doc_ref.set(settings_data)
                    migrated_count += 1
                    print(f"‚úÖ U≈ºytkownik {collection_name} zmigrowany do uprawnie≈Ñ Demo")
                else:
                    print(f"‚è≠Ô∏è U≈ºytkownik {collection_name} ju≈º ma uprawnienia: {settings_data.get('permission')}")
                    skipped_count += 1
            else:
                print(f"‚ö†Ô∏è U≈ºytkownik {collection_name} nie ma dokumentu Dane")
        
        print(f"‚úÖ Migracja zako≈Ñczona: {migrated_count} zmigrowanych, {skipped_count} pominiƒôtych")
        
        return {
            "message": "Migracja uprawnie≈Ñ zako≈Ñczona pomy≈õlnie",
            "migrated_count": migrated_count,
            "skipped_count": skipped_count,
            "total_processed": migrated_count + skipped_count
        }
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas migracji uprawnie≈Ñ: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas migracji uprawnie≈Ñ: {str(e)}")

# Endpoint do tworzenia rekordu u≈ºytkownika po rejestracji
class UserRegistrationData(BaseModel):
    username: str
    email: str
    name: str = ""
    surname: str = ""

class UserRegistrationResponse(BaseModel):
    success: bool
    message: str
    username: str
    permission: UserPermission

@app.post("/register-user", response_model=UserRegistrationResponse)
async def register_user(user_data: UserRegistrationData):
    """Utw√≥rz rekord u≈ºytkownika w bazie danych po rejestracji"""
    print(f"üë§ Rejestracja nowego u≈ºytkownika: {user_data.username}")
    print(f"üìß Email: {user_data.email}")
    
    if not db:
        print("‚ùå Firebase nie jest skonfigurowany")
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        # Sprawd≈∫ czy u≈ºytkownik ju≈º istnieje
        doc_ref = db.collection(user_data.username).document("Dane")
        doc = doc_ref.get()
        
        if doc.exists:
            print(f"‚ö†Ô∏è U≈ºytkownik {user_data.username} ju≈º istnieje w bazie danych")
            # Pobierz istniejƒÖce uprawnienia
            settings_data = doc.to_dict()
            settings = UserSettings(**settings_data)
            return UserRegistrationResponse(
                success=True,
                message="U≈ºytkownik ju≈º istnieje w bazie danych",
                username=user_data.username,
                permission=settings.permission
            )
        
        # Utw√≥rz nowy rekord u≈ºytkownika z domy≈õlnymi danymi
        now = datetime.now()
        default_settings = UserSettings(
            userData=UserData(
                name=user_data.name,
                surname=user_data.surname,
                email=user_data.email,
                companyName="",
                googleCard=""
            ),
            messaging=MessagingSettings(
                reminderFrequency=7,
                messageTemplate="""Bardzo prosimy o zostawienie opinii o naszych us≈Çugach: [LINK]
Wasza opinia ma dla nas ogromne znaczenie i pomo≈ºe kolejnym klientom w wyborze.

Dziƒôkujemy!""",
                autoSendEnabled=False,
                sendTime={"hour": 10, "minute": 0},
                smsLimit=get_sms_limit_for_permission(UserPermission.DEMO)
            ),
            twilio=TwilioSettings(
                account_sid="ACfc0d69a38f5b328bc7783fa5829336b2",
                auth_token="3d5761074605ac590f0c18494820d15f",
                phone_number="",
                messaging_service_sid="MG12792d6acd38447e77756a5ceb2c75f1"
            ),
            permission=UserPermission.DEMO  # Nowi u≈ºytkownicy domy≈õlnie majƒÖ uprawnienia Demo
        )
        
        # Zapisz ustawienia do bazy danych
        settings_dict = default_settings.dict()
        settings_dict.update({
            "created_at": now,
            "updated_at": now
        })
        
        doc_ref.set(settings_dict)
        print(f"‚úÖ U≈ºytkownik {user_data.username} zarejestrowany z uprawnieniami Demo")
        
        return UserRegistrationResponse(
            success=True,
            message=f"U≈ºytkownik {user_data.username} zosta≈Ç pomy≈õlnie zarejestrowany",
            username=user_data.username,
            permission=UserPermission.DEMO
        )
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas rejestracji u≈ºytkownika: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas rejestracji u≈ºytkownika: {str(e)}")

# Endpointy dla formularza ocen
@app.get("/review/{review_code}")
async def get_review_form(review_code: str):
    """Pobierz informacje o kliencie na podstawie kodu recenzji"""
    print(f"üîç Wyszukiwanie klienta z kodem: {review_code}")
    
    if not db:
        print("‚ùå Firebase nie jest skonfigurowany")
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        # Najpierw sprawd≈∫ w kolekcji temp_clients
        temp_clients_ref = db.collection("temp_clients")
        temp_docs = temp_clients_ref.where("review_code", "==", review_code).stream()
        
        found_client = None
        found_collection = None
        is_temp_client = False
        
        for doc in temp_docs:
            found_client = doc.to_dict()
            found_client["id"] = doc.id
            is_temp_client = True
            break
        
        # Je≈õli nie znaleziono w temp_clients, szukaj w kolekcjach u≈ºytkownik√≥w
        if not found_client:
            collections = db.collections()
            
            for collection in collections:
                collection_name = collection.id
                # Pomi≈Ñ kolekcje systemowe
                if collection_name in ["Dane", "temp_clients"]:
                    continue
                    
                docs = collection.where("review_code", "==", review_code).stream()
                
                for doc in docs:
                    found_client = doc.to_dict()
                    found_client["id"] = doc.id
                    found_collection = collection_name
                    break
                
                if found_client:
                    break
        
        if found_client:
            print(f"‚úÖ Znaleziono klienta: {found_client['name']}")
            
            # Zaktualizuj status na "opened" (formularz zosta≈Ç otwarty)
            if is_temp_client:
                doc_ref = db.collection("temp_clients").document(found_client["id"])
                doc_ref.update({
                    "status": "opened",
                    "updated_at": datetime.now()
                })
            else:
                # Znajd≈∫ kolekcjƒô u≈ºytkownika
                collections = db.collections()
                for collection in collections:
                    collection_name = collection.id
                    if collection_name in ["Dane", "temp_clients"]:
                        continue
                    docs = collection.where("review_code", "==", review_code).stream()
                    for doc in docs:
                        doc_ref = db.collection(collection_name).document(doc.id)
                        doc_ref.update({
                            "review_status": "opened",
                            "updated_at": datetime.now()
                        })
                        break
                    if docs:
                        break
            
            # Pobierz ustawienia firmy (dla wszystkich klient√≥w)
            company_name = "Twoja Firma"
            google_card = ""
            try:
                print(f"üîç Szukanie ustawie≈Ñ dla kodu: {review_code}")
                print(f"üîç Znaleziony klient: {found_client}")
                print(f"üîç Czy to temp_client: {is_temp_client}")
                print(f"üîç Kolekcja klienta: {found_collection}")
                
                # Je≈õli klient jest w temp_clients, musimy znale≈∫ƒá w≈Ça≈õciciela
                if is_temp_client:
                    print("üîç Klient jest w temp_clients - szukam w≈Ça≈õciciela")
                    # Sprawd≈∫ wszystkie kolekcje u≈ºytkownik√≥w
                    collections = db.collections()
                    for collection in collections:
                        collection_name = collection.id
                        if collection_name in ["Dane", "temp_clients"]:
                            continue
                        print(f"üîç Sprawdzanie kolekcji u≈ºytkownika: {collection_name}")
                        settings_doc = db.collection(collection_name).document("Dane").get()
                        if settings_doc.exists:
                            settings_data = settings_doc.to_dict()
                            print(f"üìã Dane ustawie≈Ñ z kolekcji {collection_name}: {settings_data}")
                            if "userData" in settings_data:
                                user_data = settings_data["userData"]
                                print(f"üë§ Dane u≈ºytkownika z kolekcji {collection_name}: {user_data}")
                                
                                # Sprawd≈∫ czy userData ma zagnie≈ºd≈ºonƒÖ strukturƒô userData
                                if "userData" in user_data:
                                    nested_user_data = user_data["userData"]
                                    print(f"üë§ Zagnie≈ºd≈ºone dane u≈ºytkownika z kolekcji {collection_name}: {nested_user_data}")
                                    if "companyName" in nested_user_data:
                                        company_name = nested_user_data["companyName"]
                                        print(f"üè¢ Nazwa firmy z kolekcji {collection_name}: {company_name}")
                                    if "googleCard" in nested_user_data:
                                        google_card = nested_user_data["googleCard"]
                                        print(f"üîó Google Card (zagnie≈ºd≈ºone) z kolekcji {collection_name}: {google_card}")
                                        print(f"üîó Google Card type: {type(google_card)}")
                                        print(f"üîó Google Card length: {len(google_card) if google_card else 0}")
                                        break  # Znaleziono ustawienia, przerwij pƒôtlƒô
                                else:
                                    # Sprawd≈∫ bezpo≈õrednio w userData
                                    if "companyName" in user_data:
                                        company_name = user_data["companyName"]
                                        print(f"üè¢ Nazwa firmy z kolekcji {collection_name}: {company_name}")
                                    if "googleCard" in user_data:
                                        google_card = user_data["googleCard"]
                                        print(f"üîó Google Card (bezpo≈õrednie) z kolekcji {collection_name}: {google_card}")
                                        print(f"üîó Google Card type: {type(google_card)}")
                                        print(f"üîó Google Card length: {len(google_card) if google_card else 0}")
                                        break  # Znaleziono ustawienia, przerwij pƒôtlƒô
                else:
                    # Klient jest w kolekcji u≈ºytkownika
                    print(f"üîç Klient jest w kolekcji u≈ºytkownika: {found_collection}")
                    settings_doc = db.collection(found_collection).document("Dane").get()
                    if settings_doc.exists:
                        settings_data = settings_doc.to_dict()
                        print(f"üìã Dane ustawie≈Ñ z kolekcji {found_collection}: {settings_data}")
                        if "userData" in settings_data:
                            user_data = settings_data["userData"]
                            print(f"üë§ Dane u≈ºytkownika z kolekcji {found_collection}: {user_data}")
                            
                            # Sprawd≈∫ czy userData ma zagnie≈ºd≈ºonƒÖ strukturƒô userData
                            if "userData" in user_data:
                                nested_user_data = user_data["userData"]
                                print(f"üë§ Zagnie≈ºd≈ºone dane u≈ºytkownika z kolekcji {found_collection}: {nested_user_data}")
                                if "companyName" in nested_user_data:
                                    company_name = nested_user_data["companyName"]
                                    print(f"üè¢ Nazwa firmy z kolekcji {found_collection}: {company_name}")
                                if "googleCard" in nested_user_data:
                                    google_card = nested_user_data["googleCard"]
                                    print(f"üîó Google Card (zagnie≈ºd≈ºone) z kolekcji {found_collection}: {google_card}")
                                    print(f"üîó Google Card type: {type(google_card)}")
                                    print(f"üîó Google Card length: {len(google_card) if google_card else 0}")
                            else:
                                # Sprawd≈∫ bezpo≈õrednio w userData
                                if "companyName" in user_data:
                                    company_name = user_data["companyName"]
                                    print(f"üè¢ Nazwa firmy z kolekcji {found_collection}: {company_name}")
                                if "googleCard" in user_data:
                                    google_card = user_data["googleCard"]
                                    print(f"üîó Google Card (bezpo≈õrednie) z kolekcji {found_collection}: {google_card}")
                                    print(f"üîó Google Card type: {type(google_card)}")
                                    print(f"üîó Google Card length: {len(google_card) if google_card else 0}")
                        else:
                            print("‚ö†Ô∏è Brak userData w ustawieniach")
                    else:
                        print(f"‚ö†Ô∏è Dokument 'Dane' nie istnieje w kolekcji {found_collection}")
            except Exception as e:
                print(f"‚ö†Ô∏è Nie mo≈ºna pobraƒá ustawie≈Ñ firmy: {e}")
            
            result = {
                "review_code": review_code,
                "client_name": found_client['name'],
                "company_name": company_name,
                "google_card": google_card
            }
            
            print(f"üîç DEBUG - Zwracane dane:")
            print(f"üîç - review_code: {result['review_code']}")
            print(f"üîç - client_name: {result['client_name']}")
            print(f"üîç - company_name: {result['company_name']}")
            print(f"üîç - google_card: {result['google_card']}")
            print(f"üîç - google_card type: {type(result['google_card'])}")
            
            return result
        else:
            print(f"‚ùå Nie znaleziono klienta z kodem: {review_code}")
            raise HTTPException(status_code=404, detail="Kod recenzji nie zosta≈Ç znaleziony")
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas wyszukiwania kodu recenzji: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas wyszukiwania kodu recenzji: {str(e)}")

@app.post("/review/{review_code}", response_model=ReviewResponse)
async def submit_review(review_code: str, review_data: ReviewSubmission):
    """Zapisz ocenƒô klienta"""
    start_time = datetime.now()
    print(f"‚≠ê Otrzymano ocenƒô dla kodu: {review_code}")
    print(f"üìä Dane oceny: {review_data.dict()}")
    print(f"‚è∞ Start time: {start_time}")
    
    if not db:
        print("‚ùå Firebase nie jest skonfigurowany")
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        # Walidacja oceny
        if review_data.stars < 1 or review_data.stars > 5:
            raise HTTPException(status_code=400, detail="Ocena musi byƒá miƒôdzy 1 a 5 gwiazdkami")
        
        # Znajd≈∫ klienta po kodzie recenzji
        found_client = None
        found_collection = None
        is_temp_client = False
        
        # Najpierw sprawd≈∫ w kolekcji temp_clients
        print("üîç Szukanie w temp_clients...")
        temp_clients_ref = db.collection("temp_clients")
        temp_docs = temp_clients_ref.where("review_code", "==", review_code).limit(1).stream()
        
        for doc in temp_docs:
            found_client = doc.to_dict()
            found_client["id"] = doc.id
            is_temp_client = True
            break
        
        # Je≈õli nie znaleziono w temp_clients, szukaj w kolekcjach u≈ºytkownik√≥w
        if not found_client:
            # Zoptymalizowane wyszukiwanie - najpierw spr√≥buj znale≈∫ƒá po typowym wzorcu username
            # Username to email z zamienionymi @ na _at_ i . na _
            potential_usernames = []
            
            # Je≈õli review_code zawiera informacje o u≈ºytkowniku, spr√≥buj je wyodrƒôbniƒá
            # Na razie przeszukaj tylko kilka najczƒô≈õciej u≈ºywanych kolekcji
            # TODO: W przysz≈Ço≈õci mo≈ºna dodaƒá mapowanie review_code -> username
            common_collections = []  # Pusty na razie, ≈ºeby nie marnowaƒá czasu
            
            for collection_name in common_collections:
                try:
                    collection_ref = db.collection(collection_name)
                    docs = collection_ref.where("review_code", "==", review_code).limit(1).stream()
                    
                    for doc in docs:
                        found_client = doc.to_dict()
                        found_client["id"] = doc.id
                        found_collection = collection_name
                        break
                    
                    if found_client:
                        break
                except Exception as e:
                    print(f"‚ö†Ô∏è B≈ÇƒÖd przeszukiwania kolekcji {collection_name}: {e}")
                    continue
            
            # Je≈õli nadal nie znaleziono, u≈ºyj pe≈Çnego przeszukiwania (wolne)
            if not found_client:
                print("üîç Uruchamianie pe≈Çnego przeszukiwania kolekcji...")
                collections = db.collections()
                
                for collection in collections:
                    collection_name = collection.id
                    if collection_name in ["Dane", "temp_clients", "notifications"]:
                        continue
                        
                    try:
                        docs = collection.where("review_code", "==", review_code).limit(1).stream()
                        
                        for doc in docs:
                            found_client = doc.to_dict()
                            found_client["id"] = doc.id
                            found_collection = collection_name
                            break
                        
                        if found_client:
                            break
                    except Exception as e:
                        print(f"‚ö†Ô∏è B≈ÇƒÖd przeszukiwania kolekcji {collection_name}: {e}")
                        continue
        
        if not found_client:
            print(f"‚ùå Nie znaleziono klienta z kodem: {review_code}")
            raise HTTPException(status_code=404, detail="Kod recenzji nie zosta≈Ç znaleziony")
        
        # Zaktualizuj dane klienta z nowƒÖ recenzjƒÖ
        owner_username = None
        
        if is_temp_client:
            # Dla tymczasowych klient√≥w
            doc_ref = db.collection("temp_clients").document(found_client["id"])
            doc_ref.update({
                "stars": review_data.stars,
                "review": review_data.review,
                "status": "completed",
                "updated_at": datetime.now()
            })
            print(f"‚úÖ Zaktualizowano tymczasowego klienta: {found_client['id']}")
            
            # Pobierz w≈Ça≈õciciela z danych klienta tymczasowego
            owner_username = found_client.get("owner_username")
        else:
            # Dla sta≈Çych klient√≥w - u≈ºyj zapisanej nazwy kolekcji
            if found_collection:
                doc_ref = db.collection(found_collection).document(found_client["id"])
                doc_ref.update({
                    "stars": review_data.stars,
                    "review": review_data.review,
                    "review_status": "completed",
                    "updated_at": datetime.now()
                })
                print(f"‚úÖ Zaktualizowano klienta w kolekcji {found_collection}: {found_client['id']}")
                owner_username = found_collection
            else:
                print(f"‚ö†Ô∏è Nie znaleziono kolekcji dla klienta")
                raise HTTPException(status_code=500, detail="Nie mo≈ºna zaktualizowaƒá klienta")
        
        print(f"‚úÖ Ocena zapisana: {review_data.stars} gwiazdek dla {found_client['name']}")
        print(f"üí¨ Recenzja: {review_data.review}")
        
        # Utw√≥rz powiadomienie dla w≈Ça≈õciciela (dla WSZYSTKICH opinii 1-5 gwiazdek)
        try:
            # Znajd≈∫ email w≈Ça≈õciciela na podstawie username
            owner_email = None
            if owner_username:
                # Pobierz email z ustawie≈Ñ u≈ºytkownika
                settings_doc = db.collection(owner_username).document("Dane").get()
                if settings_doc.exists:
                    settings_data = settings_doc.to_dict()
                    owner_email = settings_data.get("userData", {}).get("email", "")
            
            if owner_email:
                # Utw√≥rz powiadomienie dla WSZYSTKICH opinii (1-5 gwiazdek)
                client_name = found_client.get('name', 'Klient')
                stars_emoji = "‚≠ê" * review_data.stars
                
                # Dostosuj tytu≈Ç w zale≈ºno≈õci od oceny
                if review_data.stars >= 4:
                    title = f"üéâ ≈öwietna opinia od {client_name}!"
                elif review_data.stars == 3:
                    title = f"üìù Nowa opinia od {client_name}"
                else:
                    title = f"‚ö†Ô∏è Opinia wymagajƒÖca uwagi od {client_name}"
                
                # Przygotuj wiadomo≈õƒá
                review_preview = review_data.review[:80] if review_data.review else "Brak tre≈õci recenzji"
                if len(review_data.review) > 80:
                    review_preview += "..."
                
                message = f"{stars_emoji} ({review_data.stars}/5)\n{review_preview}"
                
                notification_ref = db.collection("notifications").document()
                notification_data = {
                    "user_email": owner_email,
                    "type": "review",
                    "title": title,
                    "message": message,
                    "read": False,
                    "created_at": datetime.now().isoformat(),
                    "metadata": {
                        "client_name": client_name,
                        "stars": review_data.stars,
                        "review_code": review_code,
                        "is_temp_client": is_temp_client
                    }
                }
                notification_ref.set(notification_data)
                print(f"‚úÖ Powiadomienie utworzone dla: {owner_email} (ocena: {review_data.stars} gwiazdek)")
                
                # Wy≈õlij email z powiadomieniem
                try:
                    # Pobierz nazwƒô firmy z ustawie≈Ñ
                    company_name = "Twoja Firma"
                    if owner_username:
                        settings_doc = db.collection(owner_username).document("Dane").get()
                        if settings_doc.exists:
                            settings_data = settings_doc.to_dict()
                            user_data = settings_data.get("userData", {})
                            if "userData" in user_data:
                                nested_user_data = user_data["userData"]
                                company_name = nested_user_data.get("companyName", "Twoja Firma")
                            else:
                                company_name = user_data.get("companyName", "Twoja Firma")
                    
                    # Wy≈õlij email
                    email_result = await send_review_notification_email(
                        owner_email=owner_email,
                        client_name=client_name,
                        stars=review_data.stars,
                        review_text=review_data.review,
                        company_name=company_name
                    )
                    
                    if email_result["success"]:
                        print(f"‚úÖ Email z powiadomieniem wys≈Çany do: {owner_email}")
                    else:
                        print(f"‚ö†Ô∏è B≈ÇƒÖd wysy≈Çania emaila: {email_result['message']}")
                        
                except Exception as email_error:
                    print(f"‚ö†Ô∏è B≈ÇƒÖd wysy≈Çania emaila z powiadomieniem: {str(email_error)}")
                    # Nie przerywaj procesu je≈õli email siƒô nie powiedzie
            else:
                print(f"‚ö†Ô∏è Nie znaleziono emaila w≈Ça≈õciciela dla powiadomienia")
        except Exception as notif_error:
            print(f"‚ö†Ô∏è B≈ÇƒÖd tworzenia powiadomienia: {str(notif_error)}")
            # Nie przerywaj procesu je≈õli powiadomienie siƒô nie powiedzie
        
        end_time = datetime.now()
        duration = (end_time - start_time).total_seconds()
        print(f"‚è∞ End time: {end_time}")
        print(f"‚è±Ô∏è Total duration: {duration:.2f} seconds")
        
        return ReviewResponse(
            success=True,
            message="Dziƒôkujemy za wystawienie opinii!"
        )
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas zapisywania oceny: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas zapisywania oceny: {str(e)}")

# Endpointy dla kod√≥w QR
@app.post("/qrcode/{username}", response_model=QRCodeResponse)
async def generate_company_qr_code(username: str, request: QRCodeRequest):
    """Generuj jeden kod QR dla firmy u≈ºytkownika"""
    print(f"üî≤ Generowanie kodu QR dla firmy: {username}")
    print(f"üìè ≈ªƒÖdany rozmiar: {request.size}px")
    
    if not db:
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        # Walidacja rozmiaru
        if request.size < 50 or request.size > 1000:
            raise HTTPException(status_code=400, detail="Rozmiar kodu QR musi byƒá miƒôdzy 50 a 1000 pikseli")
        
        # Pobierz ustawienia firmy
        company_name = "Twoja Firma"
        try:
            settings_doc = db.collection(username).document("Dane").get()
            if settings_doc.exists:
                settings_data = settings_doc.to_dict()
                if "userData" in settings_data and "companyName" in settings_data["userData"]:
                    company_name = settings_data["userData"]["companyName"]
        except Exception as e:
            print(f"‚ö†Ô∏è Nie mo≈ºna pobraƒá nazwy firmy: {e}")
        
        # Generuj URL do formularza logowania klienta
        base_url = os.getenv("FRONTEND_URL", "https://next-reviews-booster-app.web.app")
        client_login_url = f"{base_url}/client-login/{username}"
        
        # Generuj kod QR z lepszƒÖ konfiguracjƒÖ
        qr_data = generate_qr_code(client_login_url, request.size)
        qr_base64 = f"data:image/png;base64,{base64.b64encode(qr_data).decode()}"
        
        print(f"‚úÖ Wygenerowano kod QR dla firmy: {company_name} (rozmiar: {request.size}px)")
        return QRCodeResponse(
            qr_code=qr_base64,
            company_name=company_name,
            review_url=client_login_url
        )
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas generowania kodu QR: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas generowania kodu QR: {str(e)}")







@app.get("/qrcode/{review_code}")
async def get_qr_code_image(review_code: str, size: int = 200):
    """Pobierz kod QR jako obraz dla konkretnego kodu recenzji"""
    print(f"üî≤ Generowanie kodu QR dla: {review_code}")
    print(f"üìè ≈ªƒÖdany rozmiar: {size}px")
    
    try:
        # Walidacja rozmiaru
        if size < 50 or size > 1000:
            raise HTTPException(status_code=400, detail="Rozmiar kodu QR musi byƒá miƒôdzy 50 a 1000 pikseli")
        
        # Generuj URL do formularza recenzji
        # U≈ºyj zmiennej ≈õrodowiskowej lub domy≈õlnego localhost
        base_url = os.getenv("FRONTEND_URL", "https://next-reviews-booster-app.web.app")
        review_url = f"{base_url}/review/{review_code}"
        
        # Generuj kod QR z lepszƒÖ konfiguracjƒÖ
        qr_data = generate_qr_code(review_url, size)
        
        return StreamingResponse(
            io.BytesIO(qr_data),
            media_type="image/png",
            headers={
                "Content-Disposition": f"inline; filename=qr_{review_code}.png",
                "Cache-Control": "public, max-age=3600"  # Cache na 1 godzinƒô
            }
        )
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas generowania kodu QR: {str(e)}")
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas generowania kodu QR: {str(e)}")

# Endpoint do logowania klienta
@app.post("/client-login/{username}", response_model=ClientLoginResponse)
async def client_login(username: str, client_data: ClientLoginRequest):
    """Zapisz dane klienta i wygeneruj kod recenzji dla konkretnego u≈ºytkownika"""
    print(f"üë§ Logowanie klienta: {client_data.name} dla u≈ºytkownika: {username}")
    
    if not db:
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        # Generuj unikalny kod recenzji
        review_code = generate_review_code()
        
        # Zapisz dane klienta w kolekcji u≈ºytkownika z informacjƒÖ o w≈Ça≈õcicielu
        now = datetime.now()
        client_data_dict = {
            "name": client_data.name,
            "phone": client_data.phone,
            "note": client_data.note,
            "stars": client_data.stars,
            "review": "",
            "review_code": review_code,
            "review_status": "not_sent",
            "created_at": now,
            "updated_at": now,
            "status": "pending_review",
            "owner_username": username,
            "last_sms_sent": None,
            "sms_count": 0,
            "source": "QR"
        }
        
        # Dodaj do kolekcji u≈ºytkownika
        user_clients_ref = db.collection(username)
        doc_ref = user_clients_ref.add(client_data_dict)[1]
        
        print(f"‚úÖ Klient zapisany z kodem: {review_code} dla u≈ºytkownika: {username}")
        
        return ClientLoginResponse(
            review_code=review_code,
            message="Dane zosta≈Çy zapisane pomy≈õlnie"
        )
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas zapisywania danych klienta: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas zapisywania danych: {str(e)}")

# Endpoint do wysy≈Çania SMS
@app.post("/send-sms/{username}/{client_id}", response_model=SMSResponse)
async def send_sms_to_client(username: str, client_id: str):
    """Wy≈õlij SMS do klienta z linkiem do opinii"""
    print(f"üì± Wysy≈Çanie SMS dla u≈ºytkownika: {username}, klient: {client_id}")
    
    if not db:
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        # Pobierz konfiguracjƒô Twilio dla u≈ºytkownika
        twilio_config = get_twilio_client_for_user(username)
        if not twilio_config:
            raise HTTPException(status_code=400, detail="Twilio nie jest skonfigurowany dla tego u≈ºytkownika")
        
        # Pobierz dane klienta
        doc_ref = db.collection(username).document(client_id)
        doc = doc_ref.get()
        
        if not doc.exists:
            raise HTTPException(status_code=404, detail="Klient nie zosta≈Ç znaleziony")
        
        client_data = doc.to_dict()
        client_phone = client_data.get("phone", "")
        client_name = client_data.get("name", "")
        review_code = client_data.get("review_code", "")
        sms_count = client_data.get("sms_count", 0)
        
        if sms_count >= 2:
            raise HTTPException(status_code=400, detail="OsiƒÖgniƒôto limit SMS dla tego klienta (maksymalnie 2 SMS)")
        
        if not client_phone:
            raise HTTPException(status_code=400, detail="Klient nie ma numeru telefonu")
        
        if not review_code:
            raise HTTPException(status_code=400, detail="Klient nie ma kodu recenzji")
        
        # Pobierz ustawienia u≈ºytkownika (szablon wiadomo≈õci)
        settings_doc = db.collection(username).document("Dane").get()
        message_template = """Dzie≈Ñ dobry!

Chcia≈Çbym przypomnieƒá o mo≈ºliwo≈õci wystawienia opinii o naszych us≈Çugach. 
Wasza opinia jest dla nas bardzo wa≈ºna i pomo≈ºe innym klientom w podjƒôciu decyzji.

Link do wystawienia opinii: [LINK]

Z g√≥ry dziƒôkujƒô za po≈õwiƒôcony czas!

Z powa≈ºaniem,
[NAZWA_FIRMY]"""
        
        company_name = "Twoja Firma"
        
        if settings_doc.exists:
            settings_data = settings_doc.to_dict()
            if "messaging" in settings_data and "messageTemplate" in settings_data["messaging"]:
                message_template = settings_data["messaging"]["messageTemplate"]
            if "userData" in settings_data and "companyName" in settings_data["userData"]:
                company_name = settings_data["userData"]["companyName"]
        
        # Generuj URL do formularza recenzji
        base_url = os.getenv("FRONTEND_URL", "https://next-reviews-booster-app.web.app")
        review_url = f"{base_url}/review/{review_code}"
        
        # Przygotuj wiadomo≈õƒá SMS
        message = message_template.replace("[LINK]", review_url).replace("[NAZWA_FIRMY]", company_name)
        
        # Wy≈õlij SMS
        result = await send_sms(client_phone, message, twilio_config, username)
        
        # Zaktualizuj status klienta
        now = datetime.now()
        doc_ref.update({
            "review_status": "sent",
            "last_sms_sent": now,
            "updated_at": now,
            "sms_count": sms_count + 1
        })
        
        print(f"‚úÖ SMS wys≈Çany do {client_name} ({client_phone})")
        
        return SMSResponse(**result)
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas wysy≈Çania SMS: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas wysy≈Çania SMS: {str(e)}")

# Endpoint do wysy≈Çania SMS bezpo≈õrednio (dla test√≥w)
@app.post("/send-sms-direct/{username}", response_model=SMSResponse)
async def send_sms_direct(username: str, sms_request: SMSRequest):
    """Wy≈õlij SMS bezpo≈õrednio (dla test√≥w)"""
    print(f"üì± Bezpo≈õrednie wysy≈Çanie SMS do: {sms_request.to_phone}")
    
    if not db:
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        # Pobierz konfiguracjƒô Twilio dla u≈ºytkownika
        twilio_config = get_twilio_client_for_user(username)
        if not twilio_config:
            raise HTTPException(status_code=400, detail="Twilio nie jest skonfigurowany dla tego u≈ºytkownika")
        
        result = await send_sms(sms_request.to_phone, sms_request.message, twilio_config, username)
        return SMSResponse(**result)
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas wysy≈Çania SMS: {str(e)}")
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas wysy≈Çania SMS: {str(e)}")

# Endpoint do rƒôcznego uruchomienia procesu wysy≈Çania przypomnie≈Ñ
@app.post("/reminders/send-now")
async def send_reminders_now():
    """Rƒôcznie uruchom proces wysy≈Çania przypomnie≈Ñ SMS"""
    print("üöÄ Rƒôczne uruchomienie procesu wysy≈Çania przypomnie≈Ñ")
    
    try:
        result = await check_and_send_reminders()
        return {
            "success": True,
            "message": "Proces wysy≈Çania przypomnie≈Ñ zako≈Ñczony",
            "timestamp": datetime.now().isoformat(),
            "result": result
        }
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas rƒôcznego wysy≈Çania przypomnie≈Ñ: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas wysy≈Çania przypomnie≈Ñ: {str(e)}")

# Endpoint do testowania wysy≈Çania przypomnie≈Ñ dla konkretnego u≈ºytkownika
@app.post("/reminders/test/{username}")
async def test_reminders_for_user(username: str):
    """Test wysy≈Çania przypomnie≈Ñ dla konkretnego u≈ºytkownika"""
    print(f"üß™ Test wysy≈Çania przypomnie≈Ñ dla u≈ºytkownika: {username}")
    
    if not db:
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        # Sprawd≈∫ ustawienia u≈ºytkownika
        settings_doc = db.collection(username).document("Dane").get()
        if not settings_doc.exists:
            raise HTTPException(status_code=404, detail="U≈ºytkownik nie zosta≈Ç znaleziony")
        
        settings_data = settings_doc.to_dict()
        auto_send_enabled = False
        reminder_frequency = 7
        
        if "messaging" in settings_data:
            messaging = settings_data["messaging"]
            auto_send_enabled = messaging.get("autoSendEnabled", False)
            reminder_frequency = messaging.get("reminderFrequency", 7)
        
        # Pobierz klient√≥w
        clients = []
        collection = db.collection(username)
        docs = collection.stream()
        
        for doc in docs:
            if doc.id == "Dane":
                continue
            
            client_data = doc.to_dict()
            clients.append({
                "id": doc.id,
                "name": client_data.get("name", ""),
                "phone": client_data.get("phone", ""),
                "review_status": client_data.get("review_status", "not_sent"),
                "last_sms_sent": client_data.get("last_sms_sent"),
                "created_at": client_data.get("created_at")
            })
        
        return {
            "success": True,
            "username": username,
            "auto_send_enabled": auto_send_enabled,
            "reminder_frequency": reminder_frequency,
            "clients_count": len(clients),
            "clients": clients,
            "timestamp": datetime.now().isoformat()
        }
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas testowania przypomnie≈Ñ: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas testowania: {str(e)}")

# Endpoint do wysy≈Çania wiadomo≈õci do wszystkich klient√≥w u≈ºytkownika (testowy)
@app.get("/sms-limit/{username}")
async def get_sms_limit(username: str):
    """Sprawd≈∫ limit SMS dla u≈ºytkownika"""
    try:
        limit_info = check_sms_limit(username)
        return {
            "username": username,
            "limit": limit_info.get("limit", 0),
            "sent": limit_info.get("sent", 0),
            "remaining": limit_info.get("remaining", 0),
            "allowed": limit_info.get("allowed", False),
            "message": limit_info.get("message", "")
        }
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas sprawdzania limitu SMS: {str(e)}")
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd sprawdzania limitu: {str(e)}")

@app.post("/send-sms-all/{username}")
async def send_sms_to_all_clients(username: str):
    """Wy≈õlij SMS do wszystkich klient√≥w u≈ºytkownika o statusie recenzji r√≥≈ºnym od 'completed'"""
    print(f"üì± Wysy≈Çanie SMS do wszystkich klient√≥w u≈ºytkownika: {username}")
    
    if not db:
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        # Pobierz konfiguracjƒô Twilio dla u≈ºytkownika
        twilio_config = get_twilio_client_for_user(username)
        if not twilio_config:
            raise HTTPException(status_code=400, detail="Twilio nie jest skonfigurowany dla tego u≈ºytkownika")
        
        # Pobierz ustawienia u≈ºytkownika (szablon wiadomo≈õci)
        settings_doc = db.collection(username).document("Dane").get()
        message_template = """Dzie≈Ñ dobry!

Chcia≈Çbym przypomnieƒá o mo≈ºliwo≈õci wystawienia opinii o naszych us≈Çugach. 
Wasza opinia jest dla nas bardzo wa≈ºna i pomo≈ºe innym klientom w podjƒôciu decyzji.

Link do wystawienia opinii: [LINK]

Z g√≥ry dziƒôkujƒô za po≈õwiƒôcony czas!

Z powa≈ºaniem,
[NAZWA_FIRMY]"""
        
        company_name = "Twoja Firma"
        
        if settings_doc.exists:
            settings_data = settings_doc.to_dict()
            if "messaging" in settings_data and "messageTemplate" in settings_data["messaging"]:
                message_template = settings_data["messaging"]["messageTemplate"]
            if "userData" in settings_data and "companyName" in settings_data["userData"]:
                company_name = settings_data["userData"]["companyName"]
        
        # Pobierz wszystkich klient√≥w u≈ºytkownika (pomijamy dokument "Dane")
        clients_collection = db.collection(username)
        docs = clients_collection.stream()
        
        clients_to_send = []
        total_sent = 0
        errors = []
        
        # Przygotuj listƒô klient√≥w do wys≈Çania
        for doc in docs:
            # Pomi≈Ñ dokument "Dane"
            if doc.id == "Dane":
                continue
            
            client_data = doc.to_dict()
            client_id = doc.id
            
            # Sprawd≈∫ warunki wysy≈Çki
            review_status = client_data.get("review_status", "not_sent")
            phone = client_data.get("phone", "")
            review_code = client_data.get("review_code", "")
            client_name = client_data.get("name", "")
            sms_count = client_data.get("sms_count", 0)
            
            # Pomi≈Ñ klient√≥w bez numeru telefonu lub kodu recenzji
            if not phone or not review_code:
                continue
            
            # Pomi≈Ñ klient√≥w kt√≥rzy ju≈º uko≈Ñczyli recenzjƒô
            if review_status == "completed":
                continue
            
            # Pomi≈Ñ klient√≥w kt√≥rzy osiƒÖgnƒôli limit SMS
            if sms_count >= 2:
                continue
            
            clients_to_send.append({
                "id": client_id,
                "name": client_name,
                "phone": phone,
                "review_code": review_code,
                "review_status": review_status
            })
        
        print(f"üìä Znaleziono {len(clients_to_send)} klient√≥w do wys≈Çania SMS")
        
        # Wy≈õlij SMS do ka≈ºdego klienta
        for client in clients_to_send:
            try:
                # Generuj URL do formularza recenzji
                base_url = os.getenv("FRONTEND_URL", "https://next-reviews-booster-app.web.app")
                review_url = f"{base_url}/review/{client['review_code']}"
                
                # Przygotuj wiadomo≈õƒá SMS
                message = message_template.replace("[LINK]", review_url).replace("[NAZWA_FIRMY]", company_name)
                
                # Wy≈õlij SMS
                print(f"üì± Wysy≈Çanie SMS do: {client['name']} ({client['phone']})")
                result = await send_sms(client['phone'], message, twilio_config, username)
                
                # Zaktualizuj status klienta
                now = datetime.now()
                doc_ref = db.collection(username).document(client['id'])
                current_client = doc_ref.get()
                current_data = current_client.to_dict()
                current_sms_count = current_data.get("sms_count", 0)
                
                update_data = {
                    "last_sms_sent": now,
                    "updated_at": now,
                    "sms_count": current_sms_count + 1
                }
                
                # Je≈õli to pierwszy SMS, zmie≈Ñ status na "sent"
                if client['review_status'] == "not_sent":
                    update_data["review_status"] = "sent"
                
                doc_ref.update(update_data)
                
                total_sent += 1
                print(f"‚úÖ SMS wys≈Çany do: {client['name']}")
                
            except Exception as sms_error:
                error_msg = f"B≈ÇƒÖd wysy≈Çania SMS do {client['name']}: {str(sms_error)}"
                print(f"‚ùå {error_msg}")
                errors.append(error_msg)
                continue
        
        return {
            "success": True,
            "message": f"Proces wysy≈Çania zako≈Ñczony. Wys≈Çano {total_sent} z {len(clients_to_send)} klient√≥w",
            "total_found": len(clients_to_send),
            "sent": total_sent,
            "errors": errors
        }
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas wysy≈Çania SMS do wszystkich klient√≥w: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas wysy≈Çania SMS: {str(e)}")

# Endpoint dla Twilio StatusCallback
@app.post("/twilio/delivery-status")
async def twilio_delivery_status(request: dict):
    """Endpoint dla statusu dostarczenia SMS od Twilio"""
    print(f"üìä Status dostarczenia SMS: {request}")
    return {"status": "received"}

# Endpoint do sprawdzenia statusu schedulera
@app.get("/reminders/status")
async def get_reminders_status():
    """Sprawd≈∫ status schedulera przypomnie≈Ñ"""
    try:
        jobs = scheduler.get_jobs()
        job_info = []
        
        for job in jobs:
            job_info.append({
                "id": job.id,
                "name": job.name,
                "next_run": job.next_run_time.isoformat() if job.next_run_time else None,
                "trigger": str(job.trigger)
            })
        
        return {
            "scheduler_running": scheduler.running,
            "jobs": job_info
        }
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas sprawdzania statusu schedulera: {str(e)}")
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas sprawdzania statusu: {str(e)}")

# Endpoint dla formularza kontaktowego
@app.post("/contact", response_model=ContactFormResponse)
async def submit_contact_form(contact_data: ContactFormRequest):
    """Wy≈õlij wiadomo≈õƒá kontaktowƒÖ"""
    print(f"üìß Otrzymano wiadomo≈õƒá kontaktowƒÖ od: {contact_data.name}")
    print(f"üìß Email: {contact_data.email}")
    if contact_data.company:
        print(f"üìß Firma: {contact_data.company}")
    
    try:
        # Walidacja danych
        if not contact_data.name.strip():
            raise HTTPException(status_code=400, detail="Imiƒô i nazwisko jest wymagane")
        
        if not contact_data.email.strip():
            raise HTTPException(status_code=400, detail="Email jest wymagany")
        
        if not contact_data.message.strip():
            raise HTTPException(status_code=400, detail="Wiadomo≈õƒá jest wymagana")
        
        # Wy≈õlij email
        result = await send_contact_email(contact_data)
        
        return ContactFormResponse(**result)
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas przetwarzania formularza kontaktowego: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas przetwarzania formularza: {str(e)}")

# Endpoint do pobierania statystyk u≈ºytkownika
@app.get("/statistics/{username}")
async def get_user_statistics(username: str):
    """Pobierz statystyki u≈ºytkownika"""
    print(f"üìä Pobieranie statystyk dla u≈ºytkownika: {username}")
    
    if not db:
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        # Pobierz wszystkich klient√≥w u≈ºytkownika
        clients_ref = db.collection(username)
        docs = clients_ref.stream()
        
        clients = []
        for doc in docs:
            # Pomi≈Ñ dokument "Dane"
            if doc.id == "Dane":
                continue
            
            client_data = doc.to_dict()
            clients.append(client_data)
        
        # Oblicz statystyki
        total_clients = len(clients)
        
        # Klienci z uko≈Ñczonymi recenzjami
        completed_reviews = [client for client in clients if client.get("review_status") == "completed"]
        total_reviews = len(completed_reviews)
        
        # ≈örednia ocena tylko z klient√≥w kt√≥rzy wystawili opinie
        clients_with_stars = [client for client in completed_reviews if client.get("stars", 0) > 0]
        average_rating = 0
        if clients_with_stars:
            total_stars = sum(client.get("stars", 0) for client in clients_with_stars)
            average_rating = round(total_stars / len(clients_with_stars), 1)
        
        # Opinie w tym miesiƒÖcu
        now = datetime.now()
        current_month = now.month
        current_year = now.year
        
        reviews_this_month = 0
        for client in completed_reviews:
            updated_at = client.get("updated_at")
            if updated_at:
                # Konwertuj Firebase Timestamp na datetime je≈õli potrzeba
                updated_at = convert_firebase_timestamp_to_naive(updated_at)
                
                if updated_at.month == current_month and updated_at.year == current_year:
                    reviews_this_month += 1
        
        # Zlicz SMS-y - zsumuj sms_count ze wszystkich klient√≥w
        sms_sent = sum(client.get("sms_count", 0) for client in clients)
        
        print(f"üìä Szczeg√≥≈Çowe statystyki SMS dla {username}:")
        print(f"   - Klienci z SMS: {len([c for c in clients if c.get('sms_count', 0) > 0])}")
        print(f"   - ≈ÅƒÖczna liczba SMS: {sms_sent}")
        for client in clients:
            if client.get("sms_count", 0) > 0:
                print(f"   - {client.get('name', 'Brak nazwy')}: {client.get('sms_count', 0)} SMS")
        
        # Wska≈∫nik konwersji
        conversion_rate = 0
        if total_clients > 0:
            conversion_rate = round((total_reviews / total_clients) * 100, 1)
        
        statistics = {
            "total_clients": total_clients,
            "total_reviews": total_reviews,
            "average_rating": average_rating,
            "reviews_this_month": reviews_this_month,
            "sms_sent": sms_sent,
            "conversion_rate": conversion_rate
        }
        
        print(f"‚úÖ Statystyki dla {username}: {statistics}")
        return statistics
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas pobierania statystyk: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas pobierania statystyk: {str(e)}")

# Endpoint do pobierania uprawnie≈Ñ na podstawie email
@app.get("/user-permission-by-email/{email}")
async def get_user_permission_by_email(email: str):
    """Pobierz uprawnienia u≈ºytkownika na podstawie email"""
    print(f"üîç Sprawdzanie uprawnie≈Ñ dla email: {email}")
    
    if not db:
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        # Najpierw spr√≥buj wygenerowaƒá username z emaila (szybsze)
        username = email.replace('@', '_at_').replace('.', '_')
        
        # Sprawd≈∫ czy taki username istnieje
        try:
            settings_doc = db.collection(username).document("Dane").get()
            if settings_doc.exists:
                settings_data = settings_doc.to_dict()
                stored_email = settings_data.get("userData", {}).get("email", "")
                
                if stored_email == email:
                    permission = settings_data.get("permission", "Demo")
                    print(f"‚úÖ Znaleziono u≈ºytkownika bezpo≈õrednio: {username}, uprawnienia: {permission}")
                    return {
                        "username": username,
                        "permission": permission,
                        "message": f"Uprawnienia u≈ºytkownika {username}: {permission}"
                    }
        except Exception as e:
            print(f"‚ö†Ô∏è Nie znaleziono bezpo≈õrednio username: {username}")
        
        # Je≈õli nie znaleziono bezpo≈õrednio, iteruj przez kolekcje (wolniejsze)
        print(f"üîç Szukam w kolekcjach...")
        collections = db.collections()
        found_username = None
        
        for collection in collections:
            collection_name = collection.id
            
            # Pomi≈Ñ kolekcje systemowe
            if collection_name in ["temp_clients", "notifications"]:
                continue
            
            try:
                settings_doc = db.collection(collection_name).document("Dane").get()
                if settings_doc.exists:
                    settings_data = settings_doc.to_dict()
                    user_email = settings_data.get("userData", {}).get("email", "")
                    if user_email == email:
                        found_username = collection_name
                        permission = settings_data.get("permission", "Demo")
                        print(f"‚úÖ Znaleziono u≈ºytkownika: {found_username}, uprawnienia: {permission}")
                        break
            except Exception as e:
                print(f"‚ö†Ô∏è B≈ÇƒÖd sprawdzania kolekcji {collection_name}: {str(e)}")
                continue
        
        if not found_username:
            print(f"‚ùå Nie znaleziono u≈ºytkownika z emailem: {email}")
            return {
                "username": None,
                "permission": "Demo",
                "message": f"Nie znaleziono u≈ºytkownika z emailem: {email}"
            }
        
        # Pobierz uprawnienia znalezionego u≈ºytkownika
        permission = get_user_permission_from_db(found_username)
        print(f"‚úÖ Uprawnienia u≈ºytkownika {found_username} (email: {email}): {permission}")
        
        return {
            "username": found_username,
            "permission": permission,
            "message": f"Uprawnienia u≈ºytkownika {found_username}: {permission}"
        }
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd pobierania uprawnie≈Ñ: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd pobierania uprawnie≈Ñ: {str(e)}")

# Endpoint do pobierania wszystkich u≈ºytkownik√≥w (tylko dla admin√≥w)
@app.get("/admin/users")
async def get_all_users():
    """Pobierz wszystkich zarejestrowanych u≈ºytkownik√≥w"""
    print(f"üë• Pobieranie wszystkich u≈ºytkownik√≥w")
    
    if not db:
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        users = []
        collections = db.collections()
        
        for collection in collections:
            collection_name = collection.id
            
            # Pomi≈Ñ kolekcje systemowe
            if collection_name in ["temp_clients"]:
                continue
            
            try:
                # Pobierz dane u≈ºytkownika
                settings_doc = db.collection(collection_name).document("Dane").get()
                if settings_doc.exists:
                    settings_data = settings_doc.to_dict()
                    
                    # WyciƒÖgnij podstawowe informacje o u≈ºytkowniku
                    user_data = settings_data.get("userData", {})
                    permission = settings_data.get("permission", "Demo")
                    twilio_settings = settings_data.get("twilio", {})
                    messaging_settings = settings_data.get("messaging", {})
                    
                    # Policz klient√≥w u≈ºytkownika i rzeczywiste SMS-y
                    clients_count = 0
                    actual_sms_sent = 0
                    try:
                        # Pobierz wszystkie dokumenty w kolekcji u≈ºytkownika (pomijajƒÖc "Dane" i "SMS")
                        user_collection = db.collection(collection_name)
                        docs = user_collection.stream()
                        for doc in docs:
                            doc_id = doc.id
                            # Pomi≈Ñ dokumenty systemowe
                            if doc_id not in ["Dane", "SMS"]:
                                clients_count += 1
                                # Zsumuj rzeczywistƒÖ liczbƒô SMS wys≈Çanych do tego klienta
                                client_data = doc.to_dict()
                                client_sms_count = client_data.get("sms_count", 0)
                                actual_sms_sent += client_sms_count
                    except Exception as e:
                        print(f"‚ö†Ô∏è B≈ÇƒÖd liczenia klient√≥w dla {collection_name}: {str(e)}")
                        clients_count = 0
                        actual_sms_sent = 0
                    
                    user_info = {
                        "username": collection_name,
                        "email": user_data.get("email", ""),
                        "name": user_data.get("name", ""),
                        "surname": user_data.get("surname", ""),
                        "companyName": user_data.get("companyName", ""),
                        "permission": permission,
                        "twilio": {
                            "account_sid": twilio_settings.get("account_sid", ""),
                            "auth_token": twilio_settings.get("auth_token", ""),
                            "phone_number": twilio_settings.get("phone_number", ""),
                            "messaging_service_sid": twilio_settings.get("messaging_service_sid", "")
                        },
                        "smsLimit": messaging_settings.get("smsLimit", 10),
                        "smsCount": actual_sms_sent,  # U≈ºyj rzeczywistej liczby SMS z bazy danych
                        "messageTemplate": messaging_settings.get("messageTemplate", ""),
                        "clientsCount": clients_count,
                        "created_at": settings_data.get("created_at", ""),
                        "updated_at": settings_data.get("updated_at", "")
                    }
                    
                    users.append(user_info)
                    print(f"‚úÖ Znaleziono u≈ºytkownika: {collection_name} ({user_data.get('email', 'Brak email')}) - SMS: {actual_sms_sent}/{messaging_settings.get('smsLimit', 10)}")
                    
            except Exception as e:
                print(f"‚ö†Ô∏è B≈ÇƒÖd pobierania danych u≈ºytkownika {collection_name}: {str(e)}")
                continue
        
        print(f"üìä Znaleziono {len(users)} u≈ºytkownik√≥w")
        return {
            "users": users,
            "total": len(users),
            "message": f"Znaleziono {len(users)} u≈ºytkownik√≥w"
        }
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd pobierania u≈ºytkownik√≥w: {str(e)}")
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd pobierania u≈ºytkownik√≥w: {str(e)}")

# Endpoint do aktualizacji uprawnie≈Ñ u≈ºytkownika
@app.put("/admin/users/{username}/permission")
async def update_user_permission_admin(username: str, permission_data: dict):
    """Aktualizuj uprawnienia u≈ºytkownika"""
    print(f"üîê Aktualizacja uprawnie≈Ñ dla {username}: {permission_data}")
    
    if not db:
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        # Sprawd≈∫ czy u≈ºytkownik istnieje
        doc_ref = db.collection(username).document("Dane")
        doc = doc_ref.get()
        
        if not doc.exists:
            raise HTTPException(status_code=404, detail=f"U≈ºytkownik {username} nie istnieje")
        
        # Pobierz aktualne dane
        settings_data = doc.to_dict()
        
        # Aktualizuj uprawnienia
        new_permission = permission_data.get("permission", "Demo")
        settings_data["permission"] = new_permission
        settings_data["updated_at"] = datetime.now().isoformat()
        
        # Aktualizuj SMS limit na podstawie nowych uprawnie≈Ñ
        sms_limit = get_sms_limit_for_permission(UserPermission(new_permission))
        if "messaging" not in settings_data:
            settings_data["messaging"] = {}
        settings_data["messaging"]["smsLimit"] = sms_limit
        
        # Zapisz zmiany
        doc_ref.set(settings_data)
        
        print(f"‚úÖ Uprawnienia zaktualizowane: {username} -> {new_permission} (SMS limit: {sms_limit})")
        
        return {
            "success": True,
            "message": f"Uprawnienia u≈ºytkownika {username} zaktualizowane na {new_permission}",
            "username": username,
            "permission": new_permission,
            "smsLimit": sms_limit
        }
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd aktualizacji uprawnie≈Ñ: {str(e)}")
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd aktualizacji uprawnie≈Ñ: {str(e)}")

# Endpoint do aktualizacji konfiguracji Twilio u≈ºytkownika
@app.put("/admin/users/{username}/twilio")
async def update_user_twilio_admin(username: str, twilio_data: dict):
    """Aktualizuj konfiguracjƒô Twilio u≈ºytkownika"""
    print(f"üì± Aktualizacja Twilio dla {username}: {twilio_data}")
    
    if not db:
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        # Sprawd≈∫ czy u≈ºytkownik istnieje
        doc_ref = db.collection(username).document("Dane")
        doc = doc_ref.get()
        
        if not doc.exists:
            raise HTTPException(status_code=404, detail=f"U≈ºytkownik {username} nie istnieje")
        
        # Pobierz aktualne dane
        settings_data = doc.to_dict()
        
        # Aktualizuj konfiguracjƒô Twilio
        if "twilio" not in settings_data:
            settings_data["twilio"] = {}
        
        settings_data["twilio"].update({
            "account_sid": twilio_data.get("account_sid", ""),
            "auth_token": twilio_data.get("auth_token", ""),
            "phone_number": twilio_data.get("phone_number", ""),
            "messaging_service_sid": twilio_data.get("messaging_service_sid", "")
        })
        
        settings_data["updated_at"] = datetime.now().isoformat()
        
        # Zapisz zmiany
        doc_ref.set(settings_data)
        
        print(f"‚úÖ Twilio zaktualizowane dla {username}")
        
        return {
            "success": True,
            "message": f"Konfiguracja Twilio dla {username} zaktualizowana",
            "username": username,
            "twilio": settings_data["twilio"]
        }
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd aktualizacji Twilio: {str(e)}")
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd aktualizacji Twilio: {str(e)}")

# Endpoint do pobierania statystyk SMS u≈ºytkownika
@app.get("/admin/users/{username}/sms-stats")
async def get_user_sms_stats(username: str):
    """Pobierz statystyki SMS u≈ºytkownika"""
    print(f"üìä Pobieranie statystyk SMS dla {username}")
    
    if not db:
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        # Sprawd≈∫ czy u≈ºytkownik istnieje
        doc_ref = db.collection(username).document("Dane")
        doc = doc_ref.get()
        
        if not doc.exists:
            raise HTTPException(status_code=404, detail=f"U≈ºytkownik {username} nie istnieje")
        
        settings_data = doc.to_dict()
        messaging_settings = settings_data.get("messaging", {})
        
        # Pobierz licznik SMS z ustawie≈Ñ
        sms_count = messaging_settings.get("smsCount", 0)
        sms_limit = messaging_settings.get("smsLimit", 10)
        
        # Pobierz szczeg√≥≈Çy SMS z kolekcji miesiƒôcznych
        current_month = datetime.now().strftime("%Y-%m")
        sms_collection = db.collection(username).document("SMS").collection(current_month)
        sms_docs = list(sms_collection.stream())
        
        # Statystyki miesiƒôczne
        monthly_sent = len(sms_docs)
        monthly_remaining = max(0, sms_limit - monthly_sent)
        
        # Statystyki z ostatnich 3 miesiƒôcy
        stats_by_month = {}
        for i in range(3):
            month = (datetime.now() - timedelta(days=30*i)).strftime("%Y-%m")
            month_collection = db.collection(username).document("SMS").collection(month)
            month_docs = list(month_collection.stream())
            stats_by_month[month] = len(month_docs)
        
        print(f"üìä Statystyki SMS dla {username}: wys≈Çane={sms_count}, limit={sms_limit}")
        
        return {
            "username": username,
            "total_sent": sms_count,
            "sms_limit": sms_limit,
            "monthly_sent": monthly_sent,
            "monthly_remaining": monthly_remaining,
            "stats_by_month": stats_by_month,
            "current_month": current_month,
            "usage_percentage": round((monthly_sent / sms_limit) * 100, 2) if sms_limit > 0 else 0
        }
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd pobierania statystyk SMS: {str(e)}")
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd pobierania statystyk SMS: {str(e)}")

# Endpoint do rƒôcznego resetowania limitu SMS
@app.post("/admin/users/{username}/reset-sms-limit")
async def reset_user_sms_limit(username: str):
    """Rƒôcznie zresetuj limit SMS dla u≈ºytkownika"""
    print(f"üîÑ Rƒôczne resetowanie limitu SMS dla {username}")
    
    if not db:
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        # Sprawd≈∫ czy u≈ºytkownik istnieje
        doc_ref = db.collection(username).document("Dane")
        doc = doc_ref.get()
        
        if not doc.exists:
            raise HTTPException(status_code=404, detail=f"U≈ºytkownik {username} nie istnieje")
        
        settings_data = doc.to_dict()
        permission = settings_data.get("permission", "Demo")
        
        # Pobierz limit na podstawie uprawnie≈Ñ
        sms_limit = get_sms_limit_for_permission(UserPermission(permission))
        current_month = datetime.now().strftime("%Y-%m")
        
        # Zresetuj limit
        success = reset_sms_limit_for_month(username, current_month, sms_limit)
        
        if success:
            return {
                "success": True,
                "message": f"Limit SMS zresetowany dla {username}",
                "username": username,
                "sms_limit": sms_limit,
                "month": current_month
            }
        else:
            raise HTTPException(status_code=500, detail="B≈ÇƒÖd resetowania limitu SMS")
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd resetowania limitu SMS: {str(e)}")
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd resetowania limitu SMS: {str(e)}")

# Endpoint do resetowania limitu SMS dla wszystkich u≈ºytkownik√≥w
@app.post("/admin/reset-all-sms-limits")
async def reset_all_sms_limits():
    """Zresetuj limit SMS dla wszystkich u≈ºytkownik√≥w (nowy miesiƒÖc)"""
    print(f"üîÑ Resetowanie limit√≥w SMS dla wszystkich u≈ºytkownik√≥w")
    
    if not db:
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        current_month = datetime.now().strftime("%Y-%m")
        reset_count = 0
        errors = []
        
        # Pobierz wszystkich u≈ºytkownik√≥w
        collections = db.collections()
        
        for collection in collections:
            collection_name = collection.id
            
            # Pomi≈Ñ kolekcje systemowe
            if collection_name in ["temp_clients"]:
                continue
            
            try:
                # Sprawd≈∫ czy to u≈ºytkownik
                settings_doc = db.collection(collection_name).document("Dane").get()
                if settings_doc.exists:
                    settings_data = settings_doc.to_dict()
                    permission = settings_data.get("permission", "Demo")
                    sms_limit = get_sms_limit_for_permission(UserPermission(permission))
                    
                    # Zresetuj limit
                    success = reset_sms_limit_for_month(collection_name, current_month, sms_limit)
                    if success:
                        reset_count += 1
                    else:
                        errors.append(f"B≈ÇƒÖd resetowania dla {collection_name}")
                        
            except Exception as e:
                errors.append(f"B≈ÇƒÖd dla {collection_name}: {str(e)}")
                continue
        
        print(f"‚úÖ Zresetowano limity dla {reset_count} u≈ºytkownik√≥w")
        
        return {
            "success": True,
            "message": f"Zresetowano limity SMS dla {reset_count} u≈ºytkownik√≥w",
            "reset_count": reset_count,
            "month": current_month,
            "errors": errors
        }
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd resetowania limit√≥w SMS: {str(e)}")
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd resetowania limit√≥w SMS: {str(e)}")


# Modele dla powiadomie≈Ñ
class Notification(BaseModel):
    id: str
    user_email: str
    type: str
    title: str
    message: str
    read: bool = False
    created_at: str

class NotificationResponse(BaseModel):
    success: bool
    notifications: List[Notification]
    message: str = ""

class NotificationReadResponse(BaseModel):
    success: bool
    message: str

# Endpointy dla powiadomie≈Ñ
@app.get("/notifications/{user_email}", response_model=NotificationResponse)
async def get_notifications(user_email: str):
    """Pobierz powiadomienia dla u≈ºytkownika"""
    print(f"üîî Pobieranie powiadomie≈Ñ dla: {user_email}")
    
    if not db:
        print("‚ùå Firebase nie jest skonfigurowany")
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        # Pobierz powiadomienia z kolekcji notifications
        # Najpierw sprawd≈∫ czy kolekcja istnieje
        notifications_ref = db.collection("notifications")
        
        # Pobierz wszystkie dokumenty dla u≈ºytkownika (bez order_by ≈ºeby nie wymagaƒá indeksu)
        query = notifications_ref.where("user_email", "==", user_email).limit(50)
        
        try:
            docs = query.stream()
            
            notifications = []
            for doc in docs:
                data = doc.to_dict()
                notifications.append(Notification(
                    id=doc.id,
                    user_email=data.get("user_email", ""),
                    type=data.get("type", "system"),
                    title=data.get("title", ""),
                    message=data.get("message", ""),
                    read=data.get("read", False),
                    created_at=data.get("created_at", "")
                ))
            
            # Sortuj w pamiƒôci po pobraniu
            notifications.sort(key=lambda x: x.created_at, reverse=True)
            
            print(f"‚úÖ Znaleziono {len(notifications)} powiadomie≈Ñ")
            
            return NotificationResponse(
                success=True,
                notifications=notifications,
                message=f"Znaleziono {len(notifications)} powiadomie≈Ñ"
            )
        except Exception as query_error:
            # Je≈õli query nie dzia≈Ça (np. brak indeksu), zwr√≥ƒá pustƒÖ listƒô
            print(f"‚ö†Ô∏è B≈ÇƒÖd zapytania powiadomie≈Ñ (mo≈ºliwy brak indeksu): {str(query_error)}")
            return NotificationResponse(
                success=True,
                notifications=[],
                message="Brak powiadomie≈Ñ lub wymagany indeks Firebase"
            )
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd pobierania powiadomie≈Ñ: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd pobierania powiadomie≈Ñ: {str(e)}")

@app.put("/notifications/{user_email}/{notification_id}/read", response_model=NotificationReadResponse)
async def mark_notification_as_read(user_email: str, notification_id: str):
    """Oznacz powiadomienie jako przeczytane"""
    print(f"üìñ Oznaczanie powiadomienia jako przeczytane: {notification_id} dla {user_email}")
    
    if not db:
        print("‚ùå Firebase nie jest skonfigurowany")
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        # Zaktualizuj powiadomienie
        notification_ref = db.collection("notifications").document(notification_id)
        notification_ref.update({
            "read": True,
            "read_at": datetime.now().isoformat()
        })
        
        print(f"‚úÖ Powiadomienie {notification_id} oznaczone jako przeczytane")
        
        return NotificationReadResponse(
            success=True,
            message="Powiadomienie oznaczone jako przeczytane"
        )
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd oznaczania powiadomienia: {str(e)}")
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd oznaczania powiadomienia: {str(e)}")

@app.put("/notifications/{user_email}/read-all", response_model=NotificationReadResponse)
async def mark_all_notifications_as_read(user_email: str):
    """Oznacz wszystkie powiadomienia jako przeczytane"""
    print(f"üìñ Oznaczanie wszystkich powiadomie≈Ñ jako przeczytane dla: {user_email}")
    
    if not db:
        print("‚ùå Firebase nie jest skonfigurowany")
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        # Znajd≈∫ wszystkie nieprzeczytane powiadomienia
        notifications_ref = db.collection("notifications")
        query = notifications_ref.where("user_email", "==", user_email).where("read", "==", False)
        docs = query.stream()
        
        # Zaktualizuj wszystkie nieprzeczytane powiadomienia
        batch = db.batch()
        count = 0
        for doc in docs:
            doc_ref = db.collection("notifications").document(doc.id)
            batch.update(doc_ref, {
                "read": True,
                "read_at": datetime.now().isoformat()
            })
            count += 1
        
        if count > 0:
            batch.commit()
        
        print(f"‚úÖ {count} powiadomie≈Ñ oznaczone jako przeczytane")
        
        return NotificationReadResponse(
            success=True,
            message=f"{count} powiadomie≈Ñ oznaczone jako przeczytane"
        )
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd oznaczania wszystkich powiadomie≈Ñ: {str(e)}")
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd oznaczania wszystkich powiadomie≈Ñ: {str(e)}")

@app.post("/notifications/{user_email}/create", response_model=NotificationReadResponse)
async def create_notification(user_email: str, notification_data: dict):
    """Utw√≥rz nowe powiadomienie (do u≈ºycia wewnƒôtrznego)"""
    print(f"üîî Tworzenie powiadomienia dla: {user_email}")
    
    if not db:
        print("‚ùå Firebase nie jest skonfigurowany")
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        # Utw√≥rz nowe powiadomienie
        notification_ref = db.collection("notifications").document()
        notification_data.update({
            "user_email": user_email,
            "read": False,
            "created_at": datetime.now().isoformat()
        })
        
        notification_ref.set(notification_data)
        
        print(f"‚úÖ Powiadomienie utworzone: {notification_ref.id}")
        
        return NotificationReadResponse(
            success=True,
            message="Powiadomienie utworzone"
        )
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd tworzenia powiadomienia: {str(e)}")
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd tworzenia powiadomienia: {str(e)}")


if __name__ == "__main__":
    port = int(os.getenv("PORT", 8000))
    
    print("üöÄ Uruchamianie next review booster API...")
    print(f"üîß Port: {port}")
    print(f"üåê API: http://0.0.0.0:{port}")
    print(f"üìö Dokumentacja: http://0.0.0.0:{port}/docs")
    print(f"‚ù§Ô∏è  Health Check: http://0.0.0.0:{port}/health")

    is_production = os.getenv("ENVIRONMENT") == "production" or os.getenv("RENDER") == "true"
    
    uvicorn.run(
        "backend_main:app", 
        host="0.0.0.0", 
        port=port, 
        reload=not is_production  
    )
