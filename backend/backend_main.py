from fastapi import FastAPI, HTTPException, Depends
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from datetime import datetime, timedelta
from typing import List, Optional
import uvicorn
import firebase_admin
from firebase_admin import credentials, firestore
import os
import secrets
import string
import qrcode
import io
import base64
from fastapi.responses import StreamingResponse
from twilio.rest import Client
from apscheduler.schedulers.background import BackgroundScheduler
import asyncio
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

def convert_firebase_timestamp_to_naive(timestamp):
    """Bezpiecznie konwertuj Firebase Timestamp na naive datetime"""
    if not timestamp:
        return None
    
    if hasattr(timestamp, 'to_pydatetime'):
        dt = timestamp.to_pydatetime()
        # Upewnij siƒô, ≈ºe to jest naive datetime (bez strefy czasowej)
        if dt.tzinfo is not None:
            dt = dt.replace(tzinfo=None)
        return dt
    elif isinstance(timestamp, str):
        try:
            dt = datetime.fromisoformat(timestamp.replace('Z', '+00:00'))
            # Upewnij siƒô, ≈ºe to jest naive datetime (bez strefy czasowej)
            if dt.tzinfo is not None:
                dt = dt.replace(tzinfo=None)
            return dt
        except:
            return None
    elif isinstance(timestamp, datetime):
        # Je≈õli ju≈º jest datetime, upewnij siƒô ≈ºe jest naive
        if timestamp.tzinfo is not None:
            return timestamp.replace(tzinfo=None)
        return timestamp
    
    return None

# Za≈Çaduj zmienne ≈õrodowiskowe z pliku .env (je≈õli istnieje)
try:
    from dotenv import load_dotenv
    load_dotenv()
    print("‚úÖ Za≈Çadowano zmienne ≈õrodowiskowe z pliku .env")
except ImportError:
    print("‚ö†Ô∏è python-dotenv nie zainstalowany - u≈ºywaj zmiennych systemowych")

# Inicjalizacja Twilio - bƒôdzie inicjalizowany per u≈ºytkownik z Firebase
twilio_client = None

# Inicjalizacja Firebase Admin
try:
    # Sprawd≈∫ czy Firebase jest ju≈º zainicjalizowany
    if not firebase_admin._apps:
        # Sprawd≈∫ czy istnieje plik z kluczem serwisowym (lokalne ≈õrodowisko)
        if os.path.exists("next-reviews-9d19c-firebase-adminsdk-fbsvc-ffec0c49f4.json"):
            cred = credentials.Certificate("next-reviews-9d19c-firebase-adminsdk-fbsvc-ffec0c49f4.json")
            firebase_admin.initialize_app(cred)
            print("‚úÖ Firebase Admin SDK zainicjalizowany z pliku lokalnego")
        else:
            firebase_config = {
                "type": "service_account",
                "project_id": os.getenv("FIREBASE_PROJECT_ID", "next-reviews-9d19c"),
                "private_key_id": os.getenv("FIREBASE_PRIVATE_KEY_ID"),
                "private_key": os.getenv("FIREBASE_PRIVATE_KEY", "").replace("\\n", "\n"),
                "client_email": os.getenv("FIREBASE_CLIENT_EMAIL"),
                "client_id": os.getenv("FIREBASE_CLIENT_ID"),
                "auth_uri": os.getenv("FIREBASE_AUTH_URI", "https://accounts.google.com/o/oauth2/auth"),
                "token_uri": os.getenv("FIREBASE_TOKEN_URI", "https://oauth2.googleapis.com/token"),
                "auth_provider_x509_cert_url": os.getenv("FIREBASE_AUTH_PROVIDER_X509_CERT_URL", "https://www.googleapis.com/oauth2/v1/certs"),
                "client_x509_cert_url": os.getenv("FIREBASE_CLIENT_X509_CERT_URL")
            }
            
            # Sprawd≈∫ czy wszystkie wymagane zmienne sƒÖ ustawione
            required_vars = ["FIREBASE_PRIVATE_KEY_ID", "FIREBASE_PRIVATE_KEY", "FIREBASE_CLIENT_EMAIL", "FIREBASE_CLIENT_ID", "FIREBASE_CLIENT_X509_CERT_URL"]
            missing_vars = [var for var in required_vars if not os.getenv(var)]
            
            if missing_vars:
                print(f"‚ö†Ô∏è BrakujƒÖce zmienne ≈õrodowiskowe: {missing_vars}")
                print("üîÑ Pr√≥ba inicjalizacji z domy≈õlnymi po≈õwiadczeniami...")
                firebase_admin.initialize_app()
            else:
                cred = credentials.Certificate(firebase_config)
                firebase_admin.initialize_app(cred)
                print("‚úÖ Firebase Admin SDK zainicjalizowany ze zmiennych ≈õrodowiskowych")
        
        print("‚úÖ Firebase Admin SDK zainicjalizowany pomy≈õlnie")
    else:
        print("‚úÖ Firebase Admin SDK ju≈º zainicjalizowany")
    
    db = firestore.client()
except Exception as e:
    print(f"‚ùå B≈ÇƒÖd inicjalizacji Firebase: {e}")
    db = None

app = FastAPI(
    title="next review booster API", 
    version="1.0.0",
    description="API dla aplikacji next review booster - zarzƒÖdzanie recenzjami"
)
app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "http://localhost:3000", 
        "https://next-reviews-9d19c.web.app",  # Stara domena Firebase (backup)
        "https://next-reviews-booster-app.web.app",  # Nowa domena Firebase
        "https://next-reviews-booster.com",  # Docelowa domena
        "https://www.next-reviews-booster.com",  # Wariant z www
        "https://next-reviews-frontend.onrender.com",  # Frontend na Render
        "https://*.onrender.com"  # Wszystkie domeny Render
    ],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

class HealthResponse(BaseModel):
    status: str
    message: str
    timestamp: datetime
    version: str = "1.0.0"

# Modele danych dla klient√≥w
class ClientCreate(BaseModel):
    name: str
    phone: str
    note: str = ""
    stars: int = 0
    review: str = ""
    review_code: str = ""
    review_status: str = "not_sent"
    last_sms_sent: Optional[datetime] = None
    sms_count: int = 0
    source: str = "CRM"

class ClientUpdate(BaseModel):
    name: Optional[str] = None
    phone: Optional[str] = None
    note: Optional[str] = None
    stars: Optional[int] = None
    review: Optional[str] = None
    review_code: Optional[str] = None
    review_status: Optional[str] = None
    last_sms_sent: Optional[datetime] = None
    sms_count: Optional[int] = None
    source: Optional[str] = None

class ClientResponse(BaseModel):
    id: str
    name: str
    phone: str
    note: str = ""
    stars: int = 0
    review: str = ""
    review_code: str = ""
    review_status: str = "not_sent"
    created_at: datetime
    updated_at: datetime
    last_sms_sent: Optional[datetime] = None
    sms_count: int = 0
    source: str = "CRM"

class ClientListResponse(BaseModel):
    clients: List[ClientResponse]
    total: int

# Modele dla ustawie≈Ñ u≈ºytkownika
class UserData(BaseModel):
    name: str
    surname: str
    email: str
    companyName: str = ""
    googleCard: str = ""

class TwilioSettings(BaseModel):
    account_sid: str = ""
    auth_token: str = ""
    phone_number: str = ""  # Zachowujemy dla kompatybilno≈õci wstecznej
    messaging_service_sid: str = ""  # Nowe pole dla Messaging Service SID

class MessagingSettings(BaseModel):
    reminderFrequency: int = 7
    messageTemplate: str = ""
    autoSendEnabled: bool = False  # Czy automatyczne wysy≈Çanie jest w≈ÇƒÖczone

class UserSettings(BaseModel):
    userData: UserData
    messaging: MessagingSettings
    twilio: Optional[TwilioSettings] = None

class UserSettingsResponse(BaseModel):
    settings: UserSettings

# Modele dla formularza ocen
class ReviewSubmission(BaseModel):
    stars: int
    review: str

class ReviewResponse(BaseModel):
    success: bool
    message: str

# Modele dla kod√≥w QR
class QRCodeRequest(BaseModel):
    size: int = 200
    format: str = "png"

class QRCodeResponse(BaseModel):
    qr_code: str
    company_name: str
    review_url: str

# Modele dla logowania klienta
class ClientLoginRequest(BaseModel):
    name: str
    phone: str
    note: str = ""
    stars: int = 0

class ClientLoginResponse(BaseModel):
    review_code: str
    message: str

# Modele dla SMS
class SMSRequest(BaseModel):
    to_phone: str
    message: str
    client_name: str = ""

class SMSResponse(BaseModel):
    success: bool
    message: str
    sid: Optional[str] = None

# Modele dla formularza kontaktowego
class ContactFormRequest(BaseModel):
    name: str
    email: str
    company: Optional[str] = ""
    message: str

class ContactFormResponse(BaseModel):
    success: bool
    message: str

# Funkcja do inicjalizacji Twilio dla konkretnego u≈ºytkownika
def get_twilio_client_for_user(username: str):
    """Pobierz klienta Twilio dla konkretnego u≈ºytkownika z Firebase"""
    if not db:
        return None
    
    try:
        # Pobierz ustawienia u≈ºytkownika
        settings_doc = db.collection(username).document("Dane").get()
        
        if not settings_doc.exists:
            print(f"‚ö†Ô∏è Brak ustawie≈Ñ dla u≈ºytkownika: {username}")
            return None
        
        settings_data = settings_doc.to_dict()
        
        # Sprawd≈∫ czy u≈ºytkownik ma skonfigurowane Twilio
        if "twilio" not in settings_data:
            print(f"‚ö†Ô∏è U≈ºytkownik {username} nie ma skonfigurowanego Twilio")
            return None
        
        twilio_config = settings_data["twilio"]
        
        account_sid = twilio_config.get("account_sid")
        auth_token = twilio_config.get("auth_token")
        phone_number = twilio_config.get("phone_number")
        messaging_service_sid = twilio_config.get("messaging_service_sid")
        
        # Sprawd≈∫ czy mamy podstawowe dane (account_sid i auth_token sƒÖ wymagane)
        if not all([account_sid, auth_token]):
            print(f"‚ö†Ô∏è Niekompletna konfiguracja Twilio dla u≈ºytkownika: {username}")
            return None
        
        # Sprawd≈∫ czy mamy messaging_service_sid (preferowane) lub phone_number (fallback)
        if not messaging_service_sid and not phone_number:
            print(f"‚ö†Ô∏è Brak messaging_service_sid ani phone_number dla u≈ºytkownika: {username}")
            return None
        
        # Utw√≥rz klienta Twilio
        client = Client(account_sid, auth_token)
        print(f"‚úÖ Twilio skonfigurowany dla u≈ºytkownika: {username}")
        
        return {
            "client": client,
            "phone_number": phone_number,
            "messaging_service_sid": messaging_service_sid
        }
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd inicjalizacji Twilio dla u≈ºytkownika {username}: {e}")
        return None

# Funkcja do wysy≈Çania SMS przez Twilio
async def send_sms(to_phone: str, message: str, twilio_config: dict) -> dict:
    """Wysy≈Ça SMS przez Twilio u≈ºywajƒÖc Messaging Service SID lub numeru telefonu"""
    if not twilio_config:
        raise HTTPException(status_code=500, detail="Twilio nie jest skonfigurowany")
    
    try:
        client = twilio_config["client"]
        messaging_service_sid = twilio_config.get("messaging_service_sid")
        phone_number = twilio_config.get("phone_number")
        
        # Wyczy≈õƒá numer telefonu (usu≈Ñ spacje, my≈õlniki)
        clean_phone = ''.join(filter(str.isdigit, to_phone))
        
        # Dodaj kod kraju je≈õli nie ma
        if not clean_phone.startswith('48') and len(clean_phone) == 9:
            clean_phone = '48' + clean_phone
        elif clean_phone.startswith('+'):
            clean_phone = clean_phone[1:]  # Usu≈Ñ +
        
        # Dodaj + na poczƒÖtku
        formatted_phone = '+' + clean_phone
        
        print(f"üì± Wysy≈Çanie SMS do: {formatted_phone}")
        print(f"üí¨ Tre≈õƒá: {message}")
        
        # U≈ºyj Messaging Service SID je≈õli dostƒôpny (preferowane), w przeciwnym razie u≈ºyj numeru telefonu
        if messaging_service_sid:
            print(f"üìû U≈ºywajƒÖc Messaging Service SID: {messaging_service_sid}")
            # Dok≈Çadnie taka sama sk≈Çadnia jak w przyk≈Çadzie Twilio SDK
            message_obj = client.messages.create(
                messaging_service_sid=messaging_service_sid,
                body=message,
                to=formatted_phone,
                status_callback=None  # Wy≈ÇƒÖcz callback URL
            )
        elif phone_number:
            print(f"üìû U≈ºywajƒÖc numeru telefonu: {phone_number}")
            message_obj = client.messages.create(
                body=message,
                from_=phone_number,
                to=formatted_phone
            )
        else:
            raise HTTPException(status_code=500, detail="Brak konfiguracji nadawcy (messaging_service_sid lub phone_number)")
        
        print(f"‚úÖ SMS wys≈Çany pomy≈õlnie. SID: {message_obj.sid}")
        
        return {
            "success": True,
            "message": "SMS zosta≈Ç wys≈Çany pomy≈õlnie",
            "sid": message_obj.sid
        }
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd wysy≈Çania SMS: {str(e)}")
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd wysy≈Çania SMS: {str(e)}")

# Funkcja do generowania unikalnego kodu recenzji
def generate_review_code():
    """Generuje unikalny kod recenzji (10 znak√≥w alfanumerycznych)"""
    alphabet = string.ascii_lowercase + string.digits
    return ''.join(secrets.choice(alphabet) for _ in range(10))

# Funkcja do wysy≈Çania emaili kontaktowych
async def send_contact_email(contact_data: ContactFormRequest) -> dict:
    """Wysy≈Ça email kontaktowy na adres kontakt@next-reviews-booster.com"""
    try:
        # Konfiguracja SMTP dla konta kontakt@next-reviews-booster.com
        smtp_server = os.getenv("SMTP_SERVER")
        smtp_port = int(os.getenv("SMTP_PORT"))
        smtp_username = os.getenv("SMTP_USERNAME")
        smtp_password = os.getenv("SMTP_PASSWORD")
        
        # Adres docelowy
        to_email = "kontakt@next-reviews-booster.com"
        
        # Przygotuj wiadomo≈õƒá email
        msg = MIMEMultipart()
        msg['From'] = smtp_username
        msg['To'] = to_email
        msg['Subject'] = f"Nowa wiadomo≈õƒá kontaktowa od {contact_data.name}"
        
        # Tre≈õƒá wiadomo≈õci
        body = f"""
Nowa wiadomo≈õƒá z formularza kontaktowego:

Imiƒô i nazwisko: {contact_data.name}
Email: {contact_data.email}
Firma: {contact_data.company if contact_data.company else 'Nie podano'}
Data: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

Wiadomo≈õƒá:
{contact_data.message}

---
Wiadomo≈õƒá wys≈Çana z formularza kontaktowego na stronie next-reviews-booster.com
"""
        
        msg.attach(MIMEText(body, 'plain', 'utf-8'))
        
        # Wy≈õlij email
        print(f"üìß Wysy≈Çanie emaila kontaktowego od: {contact_data.name}")
        print(f"üìß SMTP Server: {smtp_server}:{smtp_port}")
        
        # U≈ºyj SMTP_SSL dla portu 465 (SSL/TLS)
        if smtp_port == 465:
            server = smtplib.SMTP_SSL(smtp_server, smtp_port)
        else:
            server = smtplib.SMTP(smtp_server, smtp_port)
            server.starttls()
        
        server.login(smtp_username, smtp_password)
        
        text = msg.as_string()
        server.sendmail(smtp_username, to_email, text)
        server.quit()
        
        print(f"‚úÖ Email kontaktowy wys≈Çany pomy≈õlnie od: {contact_data.name}")
        
        return {
            "success": True,
            "message": "Wiadomo≈õƒá zosta≈Ça wys≈Çana pomy≈õlnie. Odpowiemy najszybciej jak to mo≈ºliwe."
        }
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd wysy≈Çania emaila kontaktowego: {str(e)}")
        import traceback
        traceback.print_exc()
        
        # W przypadku b≈Çƒôdu, zapisz do log√≥w jako backup
        print("=" * 50)
        print("B≈ÅƒÑD WYSY≈ÅANIA EMAILA - ZAPISYWANIE DO LOG√ìW")
        print("=" * 50)
        print(f"Od: {contact_data.name} <{contact_data.email}>")
        if contact_data.company:
            print(f"Firma: {contact_data.company}")
        print(f"Data: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print("-" * 50)
        print("Wiadomo≈õƒá:")
        print(contact_data.message)
        print("-" * 50)
        print(f"B≈ÇƒÖd SMTP: {str(e)}")
        print("=" * 50)
        
        return {
            "success": True,
            "message": "Wiadomo≈õƒá zosta≈Ça zapisana. Odpowiemy najszybciej jak to mo≈ºliwe."
        }


# Funkcja do generowania kodu QR
def generate_qr_code(data: str, size: int = 200) -> bytes:
    """Generuje kod QR jako bytes z lepszƒÖ konfiguracjƒÖ zgodnie z dokumentacjƒÖ"""
    # Oblicz box_size na podstawie ≈ºƒÖdanego rozmiaru
    # Dla wersji 1 (21x21) z border=4, ca≈Çkowity rozmiar to (21 + 2*4) * box_size
    # Dla rozmiaru 200px: box_size = 200 / (21 + 8) = ~6.9, zaokrƒÖglamy do 7
    box_size = max(4, size // 30)  # Minimum 4px na box
    
    qr = qrcode.QRCode(
        version=None,  # Automatyczny wyb√≥r wersji zgodnie z dokumentacjƒÖ
        error_correction=qrcode.constants.ERROR_CORRECT_M,  # 15% korekta b≈Çƒôd√≥w (domy≈õlne)
        box_size=box_size,
        border=4,  # Minimalny border zgodnie ze specyfikacjƒÖ
    )
    qr.add_data(data)
    qr.make(fit=True)
    
    # Generuj obraz z lepszymi kolorami
    img = qr.make_image(
        fill_color="black", 
        back_color="white"
    )
    
    # Je≈õli obraz jest za du≈ºy, przeskaluj go
    if img.size[0] > size:
        # U≈ºyj LANCZOS zamiast ANTIALIAS (nowsze wersje Pillow)
        from PIL import Image
        img = img.resize((size, size), Image.Resampling.LANCZOS)
    
    # Konwertuj do bytes z optymalizacjƒÖ
    img_bytes = io.BytesIO()
    img.save(img_bytes, format='PNG', optimize=True)
    img_bytes.seek(0)
    
    return img_bytes.getvalue()

# Funkcja do sprawdzania i wysy≈Çania cyklicznych przypomnie≈Ñ SMS
async def check_and_send_reminders():
    """Sprawd≈∫ wszystkich klient√≥w i wy≈õlij przypomnienia SMS je≈õli potrzebne"""
    print("üîÑ Rozpoczƒôcie sprawdzania przypomnie≈Ñ SMS...")
    
    if not db:
        print("‚ùå Firebase nie jest skonfigurowany")
        return
    
    try:
        # Pobierz wszystkie kolekcje u≈ºytkownik√≥w
        collections = db.collections()
        total_reminders_sent = 0
        
        for collection in collections:
            collection_name = collection.id
            
            # Pomi≈Ñ kolekcje systemowe
            if collection_name in ["temp_clients"]:
                continue
            
            print(f"üîç Sprawdzanie kolekcji: {collection_name}")
            
            # Sprawd≈∫ czy u≈ºytkownik ma w≈ÇƒÖczone automatyczne przypomnienia
            try:
                settings_doc = db.collection(collection_name).document("Dane").get()
                if not settings_doc.exists:
                    print(f"‚ö†Ô∏è Brak ustawie≈Ñ dla u≈ºytkownika: {collection_name}")
                    continue
                
                settings_data = settings_doc.to_dict()
                
                # Sprawd≈∫ czy autoSendEnabled jest w≈ÇƒÖczone
                auto_send_enabled = False
                reminder_frequency = 7  # domy≈õlnie 7 dni
                
                if "messaging" in settings_data:
                    messaging = settings_data["messaging"]
                    auto_send_enabled = messaging.get("autoSendEnabled", False)
                    reminder_frequency = messaging.get("reminderFrequency", 7)
                
                if not auto_send_enabled:
                    print(f"‚è≠Ô∏è Automatyczne przypomnienia wy≈ÇƒÖczone dla: {collection_name}")
                    continue
                
                print(f"‚úÖ Automatyczne przypomnienia w≈ÇƒÖczone (czƒôstotliwo≈õƒá: {reminder_frequency} dni)")
                
                # Pobierz konfiguracjƒô Twilio
                twilio_config = get_twilio_client_for_user(collection_name)
                if not twilio_config:
                    print(f"‚ö†Ô∏è Brak konfiguracji Twilio dla u≈ºytkownika: {collection_name}")
                    continue
                
                # Pobierz szablon wiadomo≈õci i nazwƒô firmy
                message_template = """Dzie≈Ñ dobry!

Chcia≈Çbym przypomnieƒá o mo≈ºliwo≈õci wystawienia opinii o naszych us≈Çugach. 
Wasza opinia jest dla nas bardzo wa≈ºna i pomo≈ºe innym klientom w podjƒôciu decyzji.

Link do wystawienia opinii: [LINK]

Z g√≥ry dziƒôkujƒô za po≈õwiƒôcony czas!

Z powa≈ºaniem,
[NAZWA_FIRMY]"""
                company_name = "Twoja Firma"
                
                if "messaging" in settings_data and "messageTemplate" in settings_data["messaging"]:
                    message_template = settings_data["messaging"]["messageTemplate"]
                if "userData" in settings_data and "companyName" in settings_data["userData"]:
                    company_name = settings_data["userData"]["companyName"]
                
                # Pobierz wszystkich klient√≥w tej kolekcji (pomijamy dokument "Dane")
                docs = collection.stream()
                
                for doc in docs:
                    # Pomi≈Ñ dokument "Dane"
                    if doc.id == "Dane":
                        continue
                    
                    client_data = doc.to_dict()
                    client_id = doc.id
                    
                    # Sprawd≈∫ czy klient spe≈Çnia warunki do wys≈Çania przypomnienia
                    review_status = client_data.get("review_status", "not_sent")
                    phone = client_data.get("phone", "")
                    review_code = client_data.get("review_code", "")
                    client_name = client_data.get("name", "")
                    sms_count = client_data.get("sms_count", 0)
                    
                    # Pomi≈Ñ klient√≥w bez numeru telefonu lub kodu recenzji
                    if not phone or not review_code:
                        continue
                    
                    # Pomi≈Ñ klient√≥w kt√≥rzy ju≈º uko≈Ñczyli recenzjƒô
                    if review_status == "completed":
                        continue
                    
                    # Pomi≈Ñ klient√≥w kt√≥rzy osiƒÖgnƒôli limit SMS
                    if sms_count >= 2:
                        continue
                    
                    # Sprawd≈∫ czy minƒÖ≈Ç odpowiedni czas od ostatniego SMS
                    last_sms_sent = client_data.get("last_sms_sent")
                    created_at = client_data.get("created_at")
                    
                    now = datetime.now()
                    should_send = False
                    
                    # Konwertuj Firebase Timestamp na datetime je≈õli potrzeba
                    last_sms_sent = convert_firebase_timestamp_to_naive(last_sms_sent)
                    created_at = convert_firebase_timestamp_to_naive(created_at)
                    
                    print(f"üîç Sprawdzanie klienta: {client_name}")
                    print(f"   - Status: {review_status}")
                    print(f"   - Ostatni SMS: {last_sms_sent}")
                    print(f"   - Czƒôstotliwo≈õƒá: {reminder_frequency} dni")
                    
                    if review_status == "not_sent":
                        # Je≈õli nigdy nie wys≈Çano SMS, wy≈õlij pierwszy raz
                        if not last_sms_sent:
                            should_send = True
                            print(f"üì§ Pierwszy SMS dla: {client_name}")
                    elif review_status in ["sent", "opened"]:
                        # Je≈õli SMS by≈Ç wys≈Çany lub link by≈Ç otwarty, sprawd≈∫ czy minƒÖ≈Ç czas na przypomnienie
                        if last_sms_sent:
                            # U≈ºyj total_seconds() zamiast days dla dok≈Çadniejszego por√≥wnania
                            time_diff = now - last_sms_sent
                            hours_since_last_sms = time_diff.total_seconds() / 3600
                            days_since_last_sms = time_diff.days
                            
                            print(f"   - Godziny od ostatniego SMS: {hours_since_last_sms:.2f}")
                            print(f"   - Dni od ostatniego SMS: {days_since_last_sms}")
                            
                            # Dla czƒôstotliwo≈õci 1 dzie≈Ñ - sprawd≈∫ czy minƒô≈Ço co najmniej 24 godziny
                            if reminder_frequency == 1:
                                if hours_since_last_sms >= 24:
                                    should_send = True
                                    print(f"üîî Przypomnienie dla: {client_name} (ostatni SMS: {hours_since_last_sms:.1f} godzin temu)")
                            else:
                                # Dla innych czƒôstotliwo≈õci u≈ºywaj dni
                                if days_since_last_sms >= reminder_frequency:
                                    should_send = True
                                    print(f"üîî Przypomnienie dla: {client_name} (ostatni SMS: {days_since_last_sms} dni temu)")
                    
                    if should_send:
                        try:
                            # Przygotuj URL do recenzji
                            base_url = os.getenv("FRONTEND_URL", "https://next-reviews-booster-app.web.app")
                            review_url = f"{base_url}/review/{review_code}"
                            
                            # Przygotuj wiadomo≈õƒá
                            message = message_template.replace("[LINK]", review_url).replace("[NAZWA_FIRMY]", company_name)
                            
                            # Wy≈õlij SMS
                            print(f"üì± Wysy≈Çanie przypomnienia SMS do: {client_name} ({phone})")
                            result = await send_sms(phone, message, twilio_config)
                            
                            # Zaktualizuj status klienta
                            doc_ref = db.collection(collection_name).document(client_id)
                            update_data = {
                                "last_sms_sent": now,
                                "updated_at": now,
                                "sms_count": sms_count + 1
                            }
                            
                            # Je≈õli to pierwszy SMS, zmie≈Ñ status na "sent"
                            if review_status == "not_sent":
                                update_data["review_status"] = "sent"
                            
                            doc_ref.update(update_data)
                            
                            total_reminders_sent += 1
                            print(f"‚úÖ Przypomnienie wys≈Çane do: {client_name}")
                            
                        except Exception as sms_error:
                            print(f"‚ùå B≈ÇƒÖd wysy≈Çania SMS do {client_name}: {str(sms_error)}")
                            continue
                
            except Exception as user_error:
                print(f"‚ùå B≈ÇƒÖd przetwarzania u≈ºytkownika {collection_name}: {str(user_error)}")
                continue
        
        print(f"‚úÖ Sprawdzanie zako≈Ñczone. Wys≈Çano {total_reminders_sent} przypomnie≈Ñ")
        return {"reminders_sent": total_reminders_sent}
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas sprawdzania przypomnie≈Ñ: {str(e)}")
        import traceback
        traceback.print_exc()
        return {"error": str(e)}

# Inicjalizacja schedulera
scheduler = BackgroundScheduler()

def run_async_check_and_send_reminders():
    """Wrapper do uruchamiania async funkcji w scheduler"""
    try:
        print(f"üïê [{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Uruchamianie schedulera przypomnie≈Ñ SMS...")
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        result = loop.run_until_complete(check_and_send_reminders())
        loop.close()
        print(f"‚úÖ [{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Scheduler zako≈Ñczony: {result}")
    except Exception as e:
        print(f"‚ùå [{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] B≈ÇƒÖd w schedulerze: {str(e)}")
        import traceback
        traceback.print_exc()

# Dodaj zadanie do schedulera - sprawdzaj co godzinƒô
scheduler.add_job(
    run_async_check_and_send_reminders,
    'interval',
    hours=1,
    id='check_reminders',
    name='Sprawdzanie i wysy≈Çanie przypomnie≈Ñ SMS',
    replace_existing=True
)

# Uruchom scheduler
scheduler.start()
print("‚úÖ Scheduler przypomnie≈Ñ SMS uruchomiony (sprawdzanie co godzinƒô)")

@app.get("/health", response_model=HealthResponse)
async def health_check():
    return HealthResponse(
        status="ok",
        message="next review booster API dzia≈Ça poprawnie! üöÄ",
        timestamp=datetime.now(),
        version="1.0.0"
    )

@app.get("/")
async def root():
    return {
        "message": "Witaj w next review booster API! üéâ",
        "version": "1.0.0",
        "docs": "/docs",
        "health": "/health"
    }

# Endpointy dla klient√≥w
@app.post("/clients/{username}", response_model=ClientResponse)
async def create_client(username: str, client_data: ClientCreate):
    """Dodaj nowego klienta do kolekcji u≈ºytkownika"""
    print(f"‚ûï Dodawanie klienta dla u≈ºytkownika: {username}")
    print(f"üìä Dane klienta: {client_data.dict()}")
    
    if not db:
        print("‚ùå Firebase nie jest skonfigurowany")
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        # Kolekcja nazywa siƒô tak jak username
        clients_ref = db.collection(username)
        print(f"üìÇ Kolekcja: {username}")
        
        # Dodaj timestampy i wygeneruj kod recenzji
        now = datetime.now()
        client_dict = client_data.dict()
        review_code = generate_review_code()
        client_dict.update({
            "created_at": now,
            "updated_at": now,
            "review_code": review_code,
            "review_status": "not_sent",
            "last_sms_sent": None,
            "sms_count": 0,
            "source": "CRM"
        })
        print(f"üìù Dane do zapisu: {client_dict}")
        print(f"üîë Wygenerowany kod recenzji: {review_code}")
        
        # Dodaj klienta do Firestore
        doc_ref = clients_ref.add(client_dict)[1]
        print(f"‚úÖ Klient dodany z ID: {doc_ref.id}")
        
        # Pobierz dodanego klienta
        doc = doc_ref.get()
        client_data_dict = doc.to_dict()
        client_data_dict["id"] = doc.id
        print(f"üìñ Odczytane dane: {client_data_dict}")
        
        # Konwertuj Firebase Timestamp na datetime
        if "created_at" in client_data_dict:
            client_data_dict["created_at"] = convert_firebase_timestamp_to_naive(client_data_dict["created_at"])
        if "updated_at" in client_data_dict:
            client_data_dict["updated_at"] = convert_firebase_timestamp_to_naive(client_data_dict["updated_at"])
        if "last_sms_sent" in client_data_dict:
            client_data_dict["last_sms_sent"] = convert_firebase_timestamp_to_naive(client_data_dict["last_sms_sent"])
        
        # Upewnij siƒô, ≈ºe last_sms_sent istnieje
        if "last_sms_sent" not in client_data_dict:
            client_data_dict["last_sms_sent"] = None
        
        return ClientResponse(**client_data_dict)
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas dodawania klienta: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas dodawania klienta: {str(e)}")

@app.get("/clients/{username}", response_model=ClientListResponse)
async def get_clients(username: str):
    """Pobierz wszystkich klient√≥w u≈ºytkownika"""
    print(f"üîç Pobieranie klient√≥w dla u≈ºytkownika: {username}")
    
    if not db:
        print("‚ùå Firebase nie jest skonfigurowany")
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        print(f"üìÇ Pr√≥ba dostƒôpu do kolekcji: {username}")
        clients_ref = db.collection(username)
        docs = clients_ref.stream()
        
        clients = []
        doc_count = 0
        for doc in docs:
            doc_count += 1
            print(f"üìÑ Dokument {doc_count}: {doc.id}")
            
            # Pomi≈Ñ dokument "Dane" - to sƒÖ ustawienia u≈ºytkownika, nie klient
            if doc.id == "Dane":
                print(f"‚è≠Ô∏è Pomijanie dokumentu 'Dane' (ustawienia u≈ºytkownika)")
                continue
            
            client_data = doc.to_dict()
            client_data["id"] = doc.id
            print(f"üìä Dane klienta: {client_data}")
            
            try:
                # Konwertuj Firebase Timestamp na datetime
                if "created_at" in client_data:
                    client_data["created_at"] = convert_firebase_timestamp_to_naive(client_data["created_at"])
                if "updated_at" in client_data:
                    client_data["updated_at"] = convert_firebase_timestamp_to_naive(client_data["updated_at"])
                if "last_sms_sent" in client_data:
                    client_data["last_sms_sent"] = convert_firebase_timestamp_to_naive(client_data["last_sms_sent"])
                
                # Upewnij siƒô, ≈ºe wszystkie wymagane pola sƒÖ obecne
                if "note" not in client_data:
                    client_data["note"] = ""
                if "stars" not in client_data:
                    client_data["stars"] = 0
                if "review" not in client_data:
                    client_data["review"] = ""
                if "review_code" not in client_data:
                    client_data["review_code"] = ""
                if "review_status" not in client_data:
                    client_data["review_status"] = "not_sent"
                if "last_sms_sent" not in client_data:
                    client_data["last_sms_sent"] = None
                if "sms_count" not in client_data:
                    client_data["sms_count"] = 0
                if "source" not in client_data:
                    client_data["source"] = "CRM"
                
                client_response = ClientResponse(**client_data)
                clients.append(client_response)
                print(f"‚úÖ Klient {doc_count} dodany do listy")
            except Exception as validation_error:
                print(f"‚ùå B≈ÇƒÖd walidacji dla klienta {doc_count}: {validation_error}")
                print(f"üìä Problemowe dane: {client_data}")
                # Kontynuuj z nastƒôpnym dokumentem
                continue
        
        print(f"‚úÖ Znaleziono {len(clients)} klient√≥w")
        return ClientListResponse(clients=clients, total=len(clients))
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas pobierania klient√≥w: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas pobierania klient√≥w: {str(e)}")

@app.get("/clients/{username}/{client_id}", response_model=ClientResponse)
async def get_client(username: str, client_id: str):
    """Pobierz konkretnego klienta"""
    if not db:
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        doc_ref = db.collection(username).document(client_id)
        doc = doc_ref.get()
        
        if not doc.exists:
            raise HTTPException(status_code=404, detail="Klient nie zosta≈Ç znaleziony")
        
        client_data = doc.to_dict()
        client_data["id"] = doc.id
        
        # Konwertuj Firebase Timestamp na datetime
        if "created_at" in client_data and hasattr(client_data["created_at"], 'to_pydatetime'):
            client_data["created_at"] = client_data["created_at"].to_pydatetime()
        if "updated_at" in client_data and hasattr(client_data["updated_at"], 'to_pydatetime'):
            client_data["updated_at"] = client_data["updated_at"].to_pydatetime()
        if "last_sms_sent" in client_data and client_data["last_sms_sent"] and hasattr(client_data["last_sms_sent"], 'to_pydatetime'):
            client_data["last_sms_sent"] = client_data["last_sms_sent"].to_pydatetime()
        
        # Upewnij siƒô, ≈ºe last_sms_sent istnieje
        if "last_sms_sent" not in client_data:
            client_data["last_sms_sent"] = None
        
        return ClientResponse(**client_data)
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas pobierania klienta: {str(e)}")

@app.put("/clients/{username}/{client_id}", response_model=ClientResponse)
async def update_client(username: str, client_id: str, client_data: ClientUpdate):
    """Zaktualizuj klienta"""
    if not db:
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        doc_ref = db.collection(username).document(client_id)
        doc = doc_ref.get()
        
        if not doc.exists:
            raise HTTPException(status_code=404, detail="Klient nie zosta≈Ç znaleziony")
        
        # Przygotuj dane do aktualizacji (tylko nie-None warto≈õci)
        update_data = {k: v for k, v in client_data.dict().items() if v is not None}
        update_data["updated_at"] = datetime.now()
        
        # Zaktualizuj dokument
        doc_ref.update(update_data)
        
        # Pobierz zaktualizowany dokument
        updated_doc = doc_ref.get()
        client_data_dict = updated_doc.to_dict()
        client_data_dict["id"] = updated_doc.id
        
        # Konwertuj Firebase Timestamp na datetime
        if "created_at" in client_data_dict:
            client_data_dict["created_at"] = convert_firebase_timestamp_to_naive(client_data_dict["created_at"])
        if "updated_at" in client_data_dict:
            client_data_dict["updated_at"] = convert_firebase_timestamp_to_naive(client_data_dict["updated_at"])
        if "last_sms_sent" in client_data_dict:
            client_data_dict["last_sms_sent"] = convert_firebase_timestamp_to_naive(client_data_dict["last_sms_sent"])
        
        # Upewnij siƒô, ≈ºe last_sms_sent istnieje
        if "last_sms_sent" not in client_data_dict:
            client_data_dict["last_sms_sent"] = None
        
        return ClientResponse(**client_data_dict)
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas aktualizacji klienta: {str(e)}")

@app.delete("/clients/{username}/{client_id}")
async def delete_client(username: str, client_id: str):
    """Usu≈Ñ klienta"""
    if not db:
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        doc_ref = db.collection(username).document(client_id)
        doc = doc_ref.get()
        
        if not doc.exists:
            raise HTTPException(status_code=404, detail="Klient nie zosta≈Ç znaleziony")
        
        # Usu≈Ñ dokument
        doc_ref.delete()
        
        return {"message": "Klient zosta≈Ç usuniƒôty pomy≈õlnie"}
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas usuwania klienta: {str(e)}")

# Endpointy dla ustawie≈Ñ u≈ºytkownika
@app.get("/settings/{username}", response_model=UserSettingsResponse)
async def get_user_settings(username: str):
    """Pobierz ustawienia u≈ºytkownika"""
    print(f"‚öôÔ∏è Pobieranie ustawie≈Ñ dla u≈ºytkownika: {username}")
    
    if not db:
        print("‚ùå Firebase nie jest skonfigurowany")
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        doc_ref = db.collection(username).document("Dane")
        doc = doc_ref.get()
        
        if doc.exists:
            settings_data = doc.to_dict()
            print(f"‚úÖ Znaleziono ustawienia: {settings_data}")
            return UserSettingsResponse(settings=UserSettings(**settings_data))
        else:
            print("‚ÑπÔ∏è Brak ustawie≈Ñ, zwracam domy≈õlne")
            # Zwr√≥ƒá domy≈õlne ustawienia
            default_settings = UserSettings(
                userData=UserData(
                    name="",
                    surname="",
                    email="",
                    companyName="",
                    googleCard=""
                ),
                messaging=MessagingSettings(
                    reminderFrequency=7,
                    messageTemplate="""Bardzo prosimy o zostawienie opinii o naszych us≈Çugach: [LINK]
Wasza opinia ma dla nas ogromne znaczenie i pomo≈ºe kolejnym klientom w wyborze.

Dziƒôkujemy!""",
                    autoSendEnabled=False
                ),
            )
            return UserSettingsResponse(settings=default_settings)
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas pobierania ustawie≈Ñ: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas pobierania ustawie≈Ñ: {str(e)}")

@app.put("/settings/{username}")
async def save_user_settings(username: str, settings: UserSettings):
    """Zapisz ustawienia u≈ºytkownika"""
    print(f"üíæ Zapisywanie ustawie≈Ñ dla u≈ºytkownika: {username}")
    print(f"üìä Dane ustawie≈Ñ: {settings.dict()}")
    
    if not db:
        print("‚ùå Firebase nie jest skonfigurowany")
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        doc_ref = db.collection(username).document("Dane")
        
        # Dodaj timestamp
        settings_dict = settings.dict()
        settings_dict.update({
            "updated_at": datetime.now()
        })
        
        # Zapisz do Firestore
        doc_ref.set(settings_dict)
        print(f"‚úÖ Ustawienia zapisane pomy≈õlnie")
        
        return {"message": "Ustawienia zosta≈Çy zapisane pomy≈õlnie"}
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas zapisywania ustawie≈Ñ: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas zapisywania ustawie≈Ñ: {str(e)}")

# Endpointy dla formularza ocen
@app.get("/review/{review_code}")
async def get_review_form(review_code: str):
    """Pobierz informacje o kliencie na podstawie kodu recenzji"""
    print(f"üîç Wyszukiwanie klienta z kodem: {review_code}")
    
    if not db:
        print("‚ùå Firebase nie jest skonfigurowany")
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        # Najpierw sprawd≈∫ w kolekcji temp_clients
        temp_clients_ref = db.collection("temp_clients")
        temp_docs = temp_clients_ref.where("review_code", "==", review_code).stream()
        
        found_client = None
        found_collection = None
        is_temp_client = False
        
        for doc in temp_docs:
            found_client = doc.to_dict()
            found_client["id"] = doc.id
            is_temp_client = True
            break
        
        # Je≈õli nie znaleziono w temp_clients, szukaj w kolekcjach u≈ºytkownik√≥w
        if not found_client:
            collections = db.collections()
            
            for collection in collections:
                collection_name = collection.id
                # Pomi≈Ñ kolekcje systemowe
                if collection_name in ["Dane", "temp_clients"]:
                    continue
                    
                docs = collection.where("review_code", "==", review_code).stream()
                
                for doc in docs:
                    found_client = doc.to_dict()
                    found_client["id"] = doc.id
                    found_collection = collection_name
                    break
                
                if found_client:
                    break
        
        if found_client:
            print(f"‚úÖ Znaleziono klienta: {found_client['name']}")
            
            # Zaktualizuj status na "opened" (formularz zosta≈Ç otwarty)
            if is_temp_client:
                doc_ref = db.collection("temp_clients").document(found_client["id"])
                doc_ref.update({
                    "status": "opened",
                    "updated_at": datetime.now()
                })
            else:
                # Znajd≈∫ kolekcjƒô u≈ºytkownika
                collections = db.collections()
                for collection in collections:
                    collection_name = collection.id
                    if collection_name in ["Dane", "temp_clients"]:
                        continue
                    docs = collection.where("review_code", "==", review_code).stream()
                    for doc in docs:
                        doc_ref = db.collection(collection_name).document(doc.id)
                        doc_ref.update({
                            "review_status": "opened",
                            "updated_at": datetime.now()
                        })
                        break
                    if docs:
                        break
            
            # Pobierz ustawienia firmy (dla wszystkich klient√≥w)
            company_name = "Twoja Firma"
            google_card = ""
            try:
                print(f"üîç Szukanie ustawie≈Ñ dla kodu: {review_code}")
                print(f"üîç Znaleziony klient: {found_client}")
                print(f"üîç Czy to temp_client: {is_temp_client}")
                print(f"üîç Kolekcja klienta: {found_collection}")
                
                # Je≈õli klient jest w temp_clients, musimy znale≈∫ƒá w≈Ça≈õciciela
                if is_temp_client:
                    print("üîç Klient jest w temp_clients - szukam w≈Ça≈õciciela")
                    # Sprawd≈∫ wszystkie kolekcje u≈ºytkownik√≥w
                    collections = db.collections()
                    for collection in collections:
                        collection_name = collection.id
                        if collection_name in ["Dane", "temp_clients"]:
                            continue
                        print(f"üîç Sprawdzanie kolekcji u≈ºytkownika: {collection_name}")
                        settings_doc = db.collection(collection_name).document("Dane").get()
                        if settings_doc.exists:
                            settings_data = settings_doc.to_dict()
                            print(f"üìã Dane ustawie≈Ñ z kolekcji {collection_name}: {settings_data}")
                            if "userData" in settings_data:
                                user_data = settings_data["userData"]
                                print(f"üë§ Dane u≈ºytkownika z kolekcji {collection_name}: {user_data}")
                                
                                # Sprawd≈∫ czy userData ma zagnie≈ºd≈ºonƒÖ strukturƒô userData
                                if "userData" in user_data:
                                    nested_user_data = user_data["userData"]
                                    print(f"üë§ Zagnie≈ºd≈ºone dane u≈ºytkownika z kolekcji {collection_name}: {nested_user_data}")
                                    if "companyName" in nested_user_data:
                                        company_name = nested_user_data["companyName"]
                                        print(f"üè¢ Nazwa firmy z kolekcji {collection_name}: {company_name}")
                                    if "googleCard" in nested_user_data:
                                        google_card = nested_user_data["googleCard"]
                                        print(f"üîó Google Card (zagnie≈ºd≈ºone) z kolekcji {collection_name}: {google_card}")
                                        print(f"üîó Google Card type: {type(google_card)}")
                                        print(f"üîó Google Card length: {len(google_card) if google_card else 0}")
                                        break  # Znaleziono ustawienia, przerwij pƒôtlƒô
                                else:
                                    # Sprawd≈∫ bezpo≈õrednio w userData
                                    if "companyName" in user_data:
                                        company_name = user_data["companyName"]
                                        print(f"üè¢ Nazwa firmy z kolekcji {collection_name}: {company_name}")
                                    if "googleCard" in user_data:
                                        google_card = user_data["googleCard"]
                                        print(f"üîó Google Card (bezpo≈õrednie) z kolekcji {collection_name}: {google_card}")
                                        print(f"üîó Google Card type: {type(google_card)}")
                                        print(f"üîó Google Card length: {len(google_card) if google_card else 0}")
                                        break  # Znaleziono ustawienia, przerwij pƒôtlƒô
                else:
                    # Klient jest w kolekcji u≈ºytkownika
                    print(f"üîç Klient jest w kolekcji u≈ºytkownika: {found_collection}")
                    settings_doc = db.collection(found_collection).document("Dane").get()
                    if settings_doc.exists:
                        settings_data = settings_doc.to_dict()
                        print(f"üìã Dane ustawie≈Ñ z kolekcji {found_collection}: {settings_data}")
                        if "userData" in settings_data:
                            user_data = settings_data["userData"]
                            print(f"üë§ Dane u≈ºytkownika z kolekcji {found_collection}: {user_data}")
                            
                            # Sprawd≈∫ czy userData ma zagnie≈ºd≈ºonƒÖ strukturƒô userData
                            if "userData" in user_data:
                                nested_user_data = user_data["userData"]
                                print(f"üë§ Zagnie≈ºd≈ºone dane u≈ºytkownika z kolekcji {found_collection}: {nested_user_data}")
                                if "companyName" in nested_user_data:
                                    company_name = nested_user_data["companyName"]
                                    print(f"üè¢ Nazwa firmy z kolekcji {found_collection}: {company_name}")
                                if "googleCard" in nested_user_data:
                                    google_card = nested_user_data["googleCard"]
                                    print(f"üîó Google Card (zagnie≈ºd≈ºone) z kolekcji {found_collection}: {google_card}")
                                    print(f"üîó Google Card type: {type(google_card)}")
                                    print(f"üîó Google Card length: {len(google_card) if google_card else 0}")
                            else:
                                # Sprawd≈∫ bezpo≈õrednio w userData
                                if "companyName" in user_data:
                                    company_name = user_data["companyName"]
                                    print(f"üè¢ Nazwa firmy z kolekcji {found_collection}: {company_name}")
                                if "googleCard" in user_data:
                                    google_card = user_data["googleCard"]
                                    print(f"üîó Google Card (bezpo≈õrednie) z kolekcji {found_collection}: {google_card}")
                                    print(f"üîó Google Card type: {type(google_card)}")
                                    print(f"üîó Google Card length: {len(google_card) if google_card else 0}")
                        else:
                            print("‚ö†Ô∏è Brak userData w ustawieniach")
                    else:
                        print(f"‚ö†Ô∏è Dokument 'Dane' nie istnieje w kolekcji {found_collection}")
            except Exception as e:
                print(f"‚ö†Ô∏è Nie mo≈ºna pobraƒá ustawie≈Ñ firmy: {e}")
            
            result = {
                "review_code": review_code,
                "client_name": found_client['name'],
                "company_name": company_name,
                "google_card": google_card
            }
            
            print(f"üîç DEBUG - Zwracane dane:")
            print(f"üîç - review_code: {result['review_code']}")
            print(f"üîç - client_name: {result['client_name']}")
            print(f"üîç - company_name: {result['company_name']}")
            print(f"üîç - google_card: {result['google_card']}")
            print(f"üîç - google_card type: {type(result['google_card'])}")
            
            return result
        else:
            print(f"‚ùå Nie znaleziono klienta z kodem: {review_code}")
            raise HTTPException(status_code=404, detail="Kod recenzji nie zosta≈Ç znaleziony")
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas wyszukiwania kodu recenzji: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas wyszukiwania kodu recenzji: {str(e)}")

@app.post("/review/{review_code}", response_model=ReviewResponse)
async def submit_review(review_code: str, review_data: ReviewSubmission):
    """Zapisz ocenƒô klienta"""
    print(f"‚≠ê Otrzymano ocenƒô dla kodu: {review_code}")
    print(f"üìä Dane oceny: {review_data.dict()}")
    
    if not db:
        print("‚ùå Firebase nie jest skonfigurowany")
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        # Walidacja oceny
        if review_data.stars < 1 or review_data.stars > 5:
            raise HTTPException(status_code=400, detail="Ocena musi byƒá miƒôdzy 1 a 5 gwiazdkami")
        
        # Znajd≈∫ klienta po kodzie recenzji
        found_client = None
        found_collection = None
        is_temp_client = False
        
        # Najpierw sprawd≈∫ w kolekcji temp_clients
        temp_clients_ref = db.collection("temp_clients")
        temp_docs = temp_clients_ref.where("review_code", "==", review_code).stream()
        
        for doc in temp_docs:
            found_client = doc.to_dict()
            found_client["id"] = doc.id
            is_temp_client = True
            break
        
        # Je≈õli nie znaleziono w temp_clients, szukaj w kolekcjach u≈ºytkownik√≥w
        if not found_client:
            collections = db.collections()
            
            for collection in collections:
                collection_name = collection.id
                if collection_name in ["Dane", "temp_clients"]:
                    continue
                    
                docs = collection.where("review_code", "==", review_code).stream()
                
                for doc in docs:
                    found_client = doc.to_dict()
                    found_client["id"] = doc.id
                    found_collection = collection_name
                    break
                
                if found_client:
                    break
        
        if not found_client:
            print(f"‚ùå Nie znaleziono klienta z kodem: {review_code}")
            raise HTTPException(status_code=404, detail="Kod recenzji nie zosta≈Ç znaleziony")
        
        # Zaktualizuj dane klienta z nowƒÖ recenzjƒÖ
        if is_temp_client:
            # Dla tymczasowych klient√≥w
            doc_ref = db.collection("temp_clients").document(found_client["id"])
            doc_ref.update({
                "stars": review_data.stars,
                "review": review_data.review,
                "status": "completed",
                "updated_at": datetime.now()
            })
            print(f"‚úÖ Zaktualizowano tymczasowego klienta: {found_client['id']}")
        else:
            # Dla sta≈Çych klient√≥w - u≈ºyj zapisanej nazwy kolekcji
            if found_collection:
                doc_ref = db.collection(found_collection).document(found_client["id"])
                doc_ref.update({
                    "stars": review_data.stars,
                    "review": review_data.review,
                    "review_status": "completed",
                    "updated_at": datetime.now()
                })
                print(f"‚úÖ Zaktualizowano klienta w kolekcji {found_collection}: {found_client['id']}")
            else:
                print(f"‚ö†Ô∏è Nie znaleziono kolekcji dla klienta")
                raise HTTPException(status_code=500, detail="Nie mo≈ºna zaktualizowaƒá klienta")
        
        print(f"‚úÖ Ocena zapisana: {review_data.stars} gwiazdek dla {found_client['name']}")
        print(f"üí¨ Recenzja: {review_data.review}")
        
        return ReviewResponse(
            success=True,
            message="Dziƒôkujemy za wystawienie opinii!"
        )
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas zapisywania oceny: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas zapisywania oceny: {str(e)}")

# Endpointy dla kod√≥w QR
@app.post("/qrcode/{username}", response_model=QRCodeResponse)
async def generate_company_qr_code(username: str, request: QRCodeRequest):
    """Generuj jeden kod QR dla firmy u≈ºytkownika"""
    print(f"üî≤ Generowanie kodu QR dla firmy: {username}")
    print(f"üìè ≈ªƒÖdany rozmiar: {request.size}px")
    
    if not db:
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        # Walidacja rozmiaru
        if request.size < 50 or request.size > 1000:
            raise HTTPException(status_code=400, detail="Rozmiar kodu QR musi byƒá miƒôdzy 50 a 1000 pikseli")
        
        # Pobierz ustawienia firmy
        company_name = "Twoja Firma"
        try:
            settings_doc = db.collection(username).document("Dane").get()
            if settings_doc.exists:
                settings_data = settings_doc.to_dict()
                if "userData" in settings_data and "companyName" in settings_data["userData"]:
                    company_name = settings_data["userData"]["companyName"]
        except Exception as e:
            print(f"‚ö†Ô∏è Nie mo≈ºna pobraƒá nazwy firmy: {e}")
        
        # Generuj URL do formularza logowania klienta
        base_url = os.getenv("FRONTEND_URL", "https://next-reviews-booster-app.web.app")
        client_login_url = f"{base_url}/client-login/{username}"
        
        # Generuj kod QR z lepszƒÖ konfiguracjƒÖ
        qr_data = generate_qr_code(client_login_url, request.size)
        qr_base64 = f"data:image/png;base64,{base64.b64encode(qr_data).decode()}"
        
        print(f"‚úÖ Wygenerowano kod QR dla firmy: {company_name} (rozmiar: {request.size}px)")
        return QRCodeResponse(
            qr_code=qr_base64,
            company_name=company_name,
            review_url=client_login_url
        )
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas generowania kodu QR: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas generowania kodu QR: {str(e)}")







@app.get("/qrcode/{review_code}")
async def get_qr_code_image(review_code: str, size: int = 200):
    """Pobierz kod QR jako obraz dla konkretnego kodu recenzji"""
    print(f"üî≤ Generowanie kodu QR dla: {review_code}")
    print(f"üìè ≈ªƒÖdany rozmiar: {size}px")
    
    try:
        # Walidacja rozmiaru
        if size < 50 or size > 1000:
            raise HTTPException(status_code=400, detail="Rozmiar kodu QR musi byƒá miƒôdzy 50 a 1000 pikseli")
        
        # Generuj URL do formularza recenzji
        # U≈ºyj zmiennej ≈õrodowiskowej lub domy≈õlnego localhost
        base_url = os.getenv("FRONTEND_URL", "https://next-reviews-booster-app.web.app")
        review_url = f"{base_url}/review/{review_code}"
        
        # Generuj kod QR z lepszƒÖ konfiguracjƒÖ
        qr_data = generate_qr_code(review_url, size)
        
        return StreamingResponse(
            io.BytesIO(qr_data),
            media_type="image/png",
            headers={
                "Content-Disposition": f"inline; filename=qr_{review_code}.png",
                "Cache-Control": "public, max-age=3600"  # Cache na 1 godzinƒô
            }
        )
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas generowania kodu QR: {str(e)}")
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas generowania kodu QR: {str(e)}")

# Endpoint do logowania klienta
@app.post("/client-login/{username}", response_model=ClientLoginResponse)
async def client_login(username: str, client_data: ClientLoginRequest):
    """Zapisz dane klienta i wygeneruj kod recenzji dla konkretnego u≈ºytkownika"""
    print(f"üë§ Logowanie klienta: {client_data.name} dla u≈ºytkownika: {username}")
    
    if not db:
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        # Generuj unikalny kod recenzji
        review_code = generate_review_code()
        
        # Zapisz dane klienta w kolekcji u≈ºytkownika z informacjƒÖ o w≈Ça≈õcicielu
        now = datetime.now()
        client_data_dict = {
            "name": client_data.name,
            "phone": client_data.phone,
            "note": client_data.note,
            "stars": client_data.stars,
            "review": "",
            "review_code": review_code,
            "review_status": "not_sent",
            "created_at": now,
            "updated_at": now,
            "status": "pending_review",
            "owner_username": username,
            "last_sms_sent": None,
            "sms_count": 0,
            "source": "QR"
        }
        
        # Dodaj do kolekcji u≈ºytkownika
        user_clients_ref = db.collection(username)
        doc_ref = user_clients_ref.add(client_data_dict)[1]
        
        print(f"‚úÖ Klient zapisany z kodem: {review_code} dla u≈ºytkownika: {username}")
        
        return ClientLoginResponse(
            review_code=review_code,
            message="Dane zosta≈Çy zapisane pomy≈õlnie"
        )
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas zapisywania danych klienta: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas zapisywania danych: {str(e)}")

# Endpoint do wysy≈Çania SMS
@app.post("/send-sms/{username}/{client_id}", response_model=SMSResponse)
async def send_sms_to_client(username: str, client_id: str):
    """Wy≈õlij SMS do klienta z linkiem do opinii"""
    print(f"üì± Wysy≈Çanie SMS dla u≈ºytkownika: {username}, klient: {client_id}")
    
    if not db:
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        # Pobierz konfiguracjƒô Twilio dla u≈ºytkownika
        twilio_config = get_twilio_client_for_user(username)
        if not twilio_config:
            raise HTTPException(status_code=400, detail="Twilio nie jest skonfigurowany dla tego u≈ºytkownika")
        
        # Pobierz dane klienta
        doc_ref = db.collection(username).document(client_id)
        doc = doc_ref.get()
        
        if not doc.exists:
            raise HTTPException(status_code=404, detail="Klient nie zosta≈Ç znaleziony")
        
        client_data = doc.to_dict()
        client_phone = client_data.get("phone", "")
        client_name = client_data.get("name", "")
        review_code = client_data.get("review_code", "")
        sms_count = client_data.get("sms_count", 0)
        
        if sms_count >= 2:
            raise HTTPException(status_code=400, detail="OsiƒÖgniƒôto limit SMS dla tego klienta (maksymalnie 2 SMS)")
        
        if not client_phone:
            raise HTTPException(status_code=400, detail="Klient nie ma numeru telefonu")
        
        if not review_code:
            raise HTTPException(status_code=400, detail="Klient nie ma kodu recenzji")
        
        # Pobierz ustawienia u≈ºytkownika (szablon wiadomo≈õci)
        settings_doc = db.collection(username).document("Dane").get()
        message_template = """Dzie≈Ñ dobry!

Chcia≈Çbym przypomnieƒá o mo≈ºliwo≈õci wystawienia opinii o naszych us≈Çugach. 
Wasza opinia jest dla nas bardzo wa≈ºna i pomo≈ºe innym klientom w podjƒôciu decyzji.

Link do wystawienia opinii: [LINK]

Z g√≥ry dziƒôkujƒô za po≈õwiƒôcony czas!

Z powa≈ºaniem,
[NAZWA_FIRMY]"""
        
        company_name = "Twoja Firma"
        
        if settings_doc.exists:
            settings_data = settings_doc.to_dict()
            if "messaging" in settings_data and "messageTemplate" in settings_data["messaging"]:
                message_template = settings_data["messaging"]["messageTemplate"]
            if "userData" in settings_data and "companyName" in settings_data["userData"]:
                company_name = settings_data["userData"]["companyName"]
        
        # Generuj URL do formularza recenzji
        base_url = os.getenv("FRONTEND_URL", "https://next-reviews-booster-app.web.app")
        review_url = f"{base_url}/review/{review_code}"
        
        # Przygotuj wiadomo≈õƒá SMS
        message = message_template.replace("[LINK]", review_url).replace("[NAZWA_FIRMY]", company_name)
        
        # Wy≈õlij SMS
        result = await send_sms(client_phone, message, twilio_config)
        
        # Zaktualizuj status klienta
        now = datetime.now()
        doc_ref.update({
            "review_status": "sent",
            "last_sms_sent": now,
            "updated_at": now,
            "sms_count": sms_count + 1
        })
        
        print(f"‚úÖ SMS wys≈Çany do {client_name} ({client_phone})")
        
        return SMSResponse(**result)
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas wysy≈Çania SMS: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas wysy≈Çania SMS: {str(e)}")

# Endpoint do wysy≈Çania SMS bezpo≈õrednio (dla test√≥w)
@app.post("/send-sms-direct/{username}", response_model=SMSResponse)
async def send_sms_direct(username: str, sms_request: SMSRequest):
    """Wy≈õlij SMS bezpo≈õrednio (dla test√≥w)"""
    print(f"üì± Bezpo≈õrednie wysy≈Çanie SMS do: {sms_request.to_phone}")
    
    if not db:
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        # Pobierz konfiguracjƒô Twilio dla u≈ºytkownika
        twilio_config = get_twilio_client_for_user(username)
        if not twilio_config:
            raise HTTPException(status_code=400, detail="Twilio nie jest skonfigurowany dla tego u≈ºytkownika")
        
        result = await send_sms(sms_request.to_phone, sms_request.message, twilio_config)
        return SMSResponse(**result)
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas wysy≈Çania SMS: {str(e)}")
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas wysy≈Çania SMS: {str(e)}")

# Endpoint do rƒôcznego uruchomienia procesu wysy≈Çania przypomnie≈Ñ
@app.post("/reminders/send-now")
async def send_reminders_now():
    """Rƒôcznie uruchom proces wysy≈Çania przypomnie≈Ñ SMS"""
    print("üöÄ Rƒôczne uruchomienie procesu wysy≈Çania przypomnie≈Ñ")
    
    try:
        result = await check_and_send_reminders()
        return {
            "success": True,
            "message": "Proces wysy≈Çania przypomnie≈Ñ zako≈Ñczony",
            "timestamp": datetime.now().isoformat(),
            "result": result
        }
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas rƒôcznego wysy≈Çania przypomnie≈Ñ: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas wysy≈Çania przypomnie≈Ñ: {str(e)}")

# Endpoint do testowania wysy≈Çania przypomnie≈Ñ dla konkretnego u≈ºytkownika
@app.post("/reminders/test/{username}")
async def test_reminders_for_user(username: str):
    """Test wysy≈Çania przypomnie≈Ñ dla konkretnego u≈ºytkownika"""
    print(f"üß™ Test wysy≈Çania przypomnie≈Ñ dla u≈ºytkownika: {username}")
    
    if not db:
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        # Sprawd≈∫ ustawienia u≈ºytkownika
        settings_doc = db.collection(username).document("Dane").get()
        if not settings_doc.exists:
            raise HTTPException(status_code=404, detail="U≈ºytkownik nie zosta≈Ç znaleziony")
        
        settings_data = settings_doc.to_dict()
        auto_send_enabled = False
        reminder_frequency = 7
        
        if "messaging" in settings_data:
            messaging = settings_data["messaging"]
            auto_send_enabled = messaging.get("autoSendEnabled", False)
            reminder_frequency = messaging.get("reminderFrequency", 7)
        
        # Pobierz klient√≥w
        clients = []
        collection = db.collection(username)
        docs = collection.stream()
        
        for doc in docs:
            if doc.id == "Dane":
                continue
            
            client_data = doc.to_dict()
            clients.append({
                "id": doc.id,
                "name": client_data.get("name", ""),
                "phone": client_data.get("phone", ""),
                "review_status": client_data.get("review_status", "not_sent"),
                "last_sms_sent": client_data.get("last_sms_sent"),
                "created_at": client_data.get("created_at")
            })
        
        return {
            "success": True,
            "username": username,
            "auto_send_enabled": auto_send_enabled,
            "reminder_frequency": reminder_frequency,
            "clients_count": len(clients),
            "clients": clients,
            "timestamp": datetime.now().isoformat()
        }
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas testowania przypomnie≈Ñ: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas testowania: {str(e)}")

# Endpoint do wysy≈Çania wiadomo≈õci do wszystkich klient√≥w u≈ºytkownika (testowy)
@app.post("/send-sms-all/{username}")
async def send_sms_to_all_clients(username: str):
    """Wy≈õlij SMS do wszystkich klient√≥w u≈ºytkownika o statusie recenzji r√≥≈ºnym od 'completed'"""
    print(f"üì± Wysy≈Çanie SMS do wszystkich klient√≥w u≈ºytkownika: {username}")
    
    if not db:
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        # Pobierz konfiguracjƒô Twilio dla u≈ºytkownika
        twilio_config = get_twilio_client_for_user(username)
        if not twilio_config:
            raise HTTPException(status_code=400, detail="Twilio nie jest skonfigurowany dla tego u≈ºytkownika")
        
        # Pobierz ustawienia u≈ºytkownika (szablon wiadomo≈õci)
        settings_doc = db.collection(username).document("Dane").get()
        message_template = """Dzie≈Ñ dobry!

Chcia≈Çbym przypomnieƒá o mo≈ºliwo≈õci wystawienia opinii o naszych us≈Çugach. 
Wasza opinia jest dla nas bardzo wa≈ºna i pomo≈ºe innym klientom w podjƒôciu decyzji.

Link do wystawienia opinii: [LINK]

Z g√≥ry dziƒôkujƒô za po≈õwiƒôcony czas!

Z powa≈ºaniem,
[NAZWA_FIRMY]"""
        
        company_name = "Twoja Firma"
        
        if settings_doc.exists:
            settings_data = settings_doc.to_dict()
            if "messaging" in settings_data and "messageTemplate" in settings_data["messaging"]:
                message_template = settings_data["messaging"]["messageTemplate"]
            if "userData" in settings_data and "companyName" in settings_data["userData"]:
                company_name = settings_data["userData"]["companyName"]
        
        # Pobierz wszystkich klient√≥w u≈ºytkownika (pomijamy dokument "Dane")
        clients_collection = db.collection(username)
        docs = clients_collection.stream()
        
        clients_to_send = []
        total_sent = 0
        errors = []
        
        # Przygotuj listƒô klient√≥w do wys≈Çania
        for doc in docs:
            # Pomi≈Ñ dokument "Dane"
            if doc.id == "Dane":
                continue
            
            client_data = doc.to_dict()
            client_id = doc.id
            
            # Sprawd≈∫ warunki wysy≈Çki
            review_status = client_data.get("review_status", "not_sent")
            phone = client_data.get("phone", "")
            review_code = client_data.get("review_code", "")
            client_name = client_data.get("name", "")
            sms_count = client_data.get("sms_count", 0)
            
            # Pomi≈Ñ klient√≥w bez numeru telefonu lub kodu recenzji
            if not phone or not review_code:
                continue
            
            # Pomi≈Ñ klient√≥w kt√≥rzy ju≈º uko≈Ñczyli recenzjƒô
            if review_status == "completed":
                continue
            
            # Pomi≈Ñ klient√≥w kt√≥rzy osiƒÖgnƒôli limit SMS
            if sms_count >= 2:
                continue
            
            clients_to_send.append({
                "id": client_id,
                "name": client_name,
                "phone": phone,
                "review_code": review_code,
                "review_status": review_status
            })
        
        print(f"üìä Znaleziono {len(clients_to_send)} klient√≥w do wys≈Çania SMS")
        
        # Wy≈õlij SMS do ka≈ºdego klienta
        for client in clients_to_send:
            try:
                # Generuj URL do formularza recenzji
                base_url = os.getenv("FRONTEND_URL", "https://next-reviews-booster-app.web.app")
                review_url = f"{base_url}/review/{client['review_code']}"
                
                # Przygotuj wiadomo≈õƒá SMS
                message = message_template.replace("[LINK]", review_url).replace("[NAZWA_FIRMY]", company_name)
                
                # Wy≈õlij SMS
                print(f"üì± Wysy≈Çanie SMS do: {client['name']} ({client['phone']})")
                result = await send_sms(client['phone'], message, twilio_config)
                
                # Zaktualizuj status klienta
                now = datetime.now()
                doc_ref = db.collection(username).document(client['id'])
                current_client = doc_ref.get()
                current_data = current_client.to_dict()
                current_sms_count = current_data.get("sms_count", 0)
                
                update_data = {
                    "last_sms_sent": now,
                    "updated_at": now,
                    "sms_count": current_sms_count + 1
                }
                
                # Je≈õli to pierwszy SMS, zmie≈Ñ status na "sent"
                if client['review_status'] == "not_sent":
                    update_data["review_status"] = "sent"
                
                doc_ref.update(update_data)
                
                total_sent += 1
                print(f"‚úÖ SMS wys≈Çany do: {client['name']}")
                
            except Exception as sms_error:
                error_msg = f"B≈ÇƒÖd wysy≈Çania SMS do {client['name']}: {str(sms_error)}"
                print(f"‚ùå {error_msg}")
                errors.append(error_msg)
                continue
        
        return {
            "success": True,
            "message": f"Proces wysy≈Çania zako≈Ñczony. Wys≈Çano {total_sent} z {len(clients_to_send)} klient√≥w",
            "total_found": len(clients_to_send),
            "sent": total_sent,
            "errors": errors
        }
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas wysy≈Çania SMS do wszystkich klient√≥w: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas wysy≈Çania SMS: {str(e)}")

# Endpoint dla Twilio StatusCallback
@app.post("/twilio/delivery-status")
async def twilio_delivery_status(request: dict):
    """Endpoint dla statusu dostarczenia SMS od Twilio"""
    print(f"üìä Status dostarczenia SMS: {request}")
    return {"status": "received"}

# Endpoint do sprawdzenia statusu schedulera
@app.get("/reminders/status")
async def get_reminders_status():
    """Sprawd≈∫ status schedulera przypomnie≈Ñ"""
    try:
        jobs = scheduler.get_jobs()
        job_info = []
        
        for job in jobs:
            job_info.append({
                "id": job.id,
                "name": job.name,
                "next_run": job.next_run_time.isoformat() if job.next_run_time else None,
                "trigger": str(job.trigger)
            })
        
        return {
            "scheduler_running": scheduler.running,
            "jobs": job_info
        }
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas sprawdzania statusu schedulera: {str(e)}")
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas sprawdzania statusu: {str(e)}")

# Endpoint dla formularza kontaktowego
@app.post("/contact", response_model=ContactFormResponse)
async def submit_contact_form(contact_data: ContactFormRequest):
    """Wy≈õlij wiadomo≈õƒá kontaktowƒÖ"""
    print(f"üìß Otrzymano wiadomo≈õƒá kontaktowƒÖ od: {contact_data.name}")
    print(f"üìß Email: {contact_data.email}")
    if contact_data.company:
        print(f"üìß Firma: {contact_data.company}")
    
    try:
        # Walidacja danych
        if not contact_data.name.strip():
            raise HTTPException(status_code=400, detail="Imiƒô i nazwisko jest wymagane")
        
        if not contact_data.email.strip():
            raise HTTPException(status_code=400, detail="Email jest wymagany")
        
        if not contact_data.message.strip():
            raise HTTPException(status_code=400, detail="Wiadomo≈õƒá jest wymagana")
        
        # Wy≈õlij email
        result = await send_contact_email(contact_data)
        
        return ContactFormResponse(**result)
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas przetwarzania formularza kontaktowego: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas przetwarzania formularza: {str(e)}")

# Endpoint do pobierania statystyk u≈ºytkownika
@app.get("/statistics/{username}")
async def get_user_statistics(username: str):
    """Pobierz statystyki u≈ºytkownika"""
    print(f"üìä Pobieranie statystyk dla u≈ºytkownika: {username}")
    
    if not db:
        raise HTTPException(status_code=500, detail="Firebase nie jest skonfigurowany")
    
    try:
        # Pobierz wszystkich klient√≥w u≈ºytkownika
        clients_ref = db.collection(username)
        docs = clients_ref.stream()
        
        clients = []
        for doc in docs:
            # Pomi≈Ñ dokument "Dane"
            if doc.id == "Dane":
                continue
            
            client_data = doc.to_dict()
            clients.append(client_data)
        
        # Oblicz statystyki
        total_clients = len(clients)
        
        # Klienci z uko≈Ñczonymi recenzjami
        completed_reviews = [client for client in clients if client.get("review_status") == "completed"]
        total_reviews = len(completed_reviews)
        
        # ≈örednia ocena tylko z klient√≥w kt√≥rzy wystawili opinie
        clients_with_stars = [client for client in completed_reviews if client.get("stars", 0) > 0]
        average_rating = 0
        if clients_with_stars:
            total_stars = sum(client.get("stars", 0) for client in clients_with_stars)
            average_rating = round(total_stars / len(clients_with_stars), 1)
        
        # Opinie w tym miesiƒÖcu
        now = datetime.now()
        current_month = now.month
        current_year = now.year
        
        reviews_this_month = 0
        for client in completed_reviews:
            updated_at = client.get("updated_at")
            if updated_at:
                # Konwertuj Firebase Timestamp na datetime je≈õli potrzeba
                updated_at = convert_firebase_timestamp_to_naive(updated_at)
                
                if updated_at.month == current_month and updated_at.year == current_year:
                    reviews_this_month += 1
        
        # Zlicz SMS-y
        sms_sent = len([client for client in clients if client.get("last_sms_sent")])
        
        # Wska≈∫nik konwersji
        conversion_rate = 0
        if total_clients > 0:
            conversion_rate = round((total_reviews / total_clients) * 100, 1)
        
        statistics = {
            "total_clients": total_clients,
            "total_reviews": total_reviews,
            "average_rating": average_rating,
            "reviews_this_month": reviews_this_month,
            "sms_sent": sms_sent,
            "conversion_rate": conversion_rate
        }
        
        print(f"‚úÖ Statystyki dla {username}: {statistics}")
        return statistics
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas pobierania statystyk: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd podczas pobierania statystyk: {str(e)}")

if __name__ == "__main__":
    port = int(os.getenv("PORT", 8000))
    
    print("üöÄ Uruchamianie next review booster API...")
    print(f"üîß Port: {port}")
    print(f"üåê API: http://0.0.0.0:{port}")
    print(f"üìö Dokumentacja: http://0.0.0.0:{port}/docs")
    print(f"‚ù§Ô∏è  Health Check: http://0.0.0.0:{port}/health")

    is_production = os.getenv("ENVIRONMENT") == "production" or os.getenv("RENDER") == "true"
    
    uvicorn.run(
        "backend_main:app", 
        host="0.0.0.0", 
        port=port, 
        reload=not is_production  
    )
